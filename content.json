{"pages":[],"posts":[{"title":"","text":"title: 张振民教育科技代码规范-01date: 2022-06-08 16:40:00categories: 公司文档tags: 前端 张振民教育科技代码规范-01 代码规范本身是为保证代码风格一致性和后期的可维护性，本规范主要参考了umi文档2021最新阿里代码规范（前端篇），考虑到目前各个项目人手都比较紧张，只有少数项目才有两人\b以上的共同开发，故文档不对常量名,变量名或文件名等做强制要求 项目框架所有项目都应该采用React+TypeScripe+Umi开发，后台类应用应采用Antd Pro,前端应用类使用脚手架Umi创建项目。 项目结构1234567891011121314151617src├── components└── pages ├── Welcome // 路由组件下不应该再包含其他路由组件，基于这个约定就能清楚的区分路由组件和非路由组件了 | ├── components // 对于复杂的页面可以再自己做更深层次的组织，但建议不要超过三层 | ├── Form.tsx | ├── index.tsx // 页面组件的代码 | └── index.less // 页面样式 ├── Order // 路由组件下不应该再包含其他路由组件，基于这个约定就能清楚的区分路由组件和非路由组件了 | ├── index.tsx | └── index.less ├── user // 一系列页面推荐通过小写的单一字母做 group 目录 | ├── components // group 下公用的组件集合 | ├── Login // group 下的页面 Login | ├── Register // group 下的页面 Register | └── util.ts // 这里可以有一些共用方法之类，不做推荐和约束，看业务场景自行做组织 └── * // 其它页面组件代码 所有路由组件（会配置在路由配置中的组件）我们推荐以大驼峰命名打平到 pages 下面第一级（复杂的项目可以增加 group 层级，在 group 下放置 pages）。不建议在路由组件内部再嵌套路由组件 - 不方便分辨一个组件是否是路由组件，而且不方便快速从全局定位到路由组件。我们推荐尽可能的拆分路由组件为更细粒度的组件，对于多个页面可能会用到的组件我们推荐放到 src/components 中，对于只是被单个页面依赖的（区块）组件，我们推荐就近维护到路由组件文件夹下即可。 注释规范整理需要加注释的地方 公共组件使用说明 api 目录的接口 非常见单词要加注释 涉及到一些运算方法应加注释 功能函数应加注释 eg: 12345678910111213141516171819function getTableId(index: number, data: T[]) { let sign = index; for (let i = 0; i &lt; data.length; i += 1) { const some = data.some(d =&gt; d.tableId === `add_${sign}`); if (some) sign += 1; else return `add_${sign}`; } return `add_${sign}`; }👆 不加注释完全无法理解👇 容易理解的多/** * 获取唯一ID,因为在列表中最初可能存在id 1，2，3 * 删除id 2时单纯根据下标赋id就会出现id 1，3，3 * 所以应该遍历数据源获取唯一ID */ function getTableId(index: number, data: T[]) { ... } 接口请求规范目前的项目中除了OA项目因为早期开发原因采用了dva方式请求接口，现在项目绝大部分工作场景都采用了ahooks中的\buseRequest请求接口，关于请求结果的返回类型，希望开发人员可以定义明确。 eg: 123456export interface IBudgetTotal { list: IBudget[] total: IApprovalTotal}const {run} = useRequest&lt;ZxRequestSingleData&lt;IBudgetTotal&gt;&gt;(mainBudget, {manual: true}); 如果出现接口只是用来确定,删除等操作不需要关注返回值的情况也可以不明确设定返回值。 eg: 12// 👇为导出表格接口const {run,} = useRequest&lt;ZxRequestSingleData&gt;(excelIn, {manual: true}) 还有个别情况使用了直接请求接口的方式，此时因为项目里面配置了errorConfig，所以在接口报错时依然会自动弹出错误信息，但是同时因为直接请求接口不会消费掉该异常，所以需要开发做好处理。 eg: 12345// 需要做好catch处理areaList() .then(...) .catch(() =&gt; ({})) .finally(...) 路由组件规范路由组件往往承担着非常重要的功能，所以规范希望可以尽可能在一个路由组件中拆分成更细微的页面组件。 eg: 12345&lt;AppControl.Provider value={value}&gt; &lt;Affix/&gt; &lt;ExamContent/&gt; &lt;CountDown /&gt;&lt;/AppControl.Provider&gt; 不建议: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;div className={styles.body}&gt; &lt;Spin spinning={loading}&gt; &lt;div className={styles.content}&gt; &lt;div className={styles.topper}&gt; &lt;img src={topBack} className={styles.topImg1} onClick={() =&gt; history.push('/home')} /&gt; &lt;/div&gt; &lt;div style={{ marginTop: '-150px' }}&gt; &lt;Row justify=&quot;center&quot;&gt; &lt;img src={back1} className={styles.back1} /&gt; &lt;/Row&gt; &lt;div className={styles.row2}&gt; &lt;img src={back2} className={styles.back2} /&gt; &lt;Row className={styles.textRow1}&gt; &lt;Col className={styles.pointer}&gt;01&lt;/Col&gt; &lt;Col&gt;...&lt;/Col&gt; &lt;Col className={styles.red}&gt;≥6个月&lt;/Col&gt; &lt;/Row&gt; &lt;Row className={styles.textRow2}&gt; &lt;Col className={styles.pointer}&gt;02&lt;/Col&gt; &lt;Col&gt;...&lt;/Col&gt; &lt;Col className={styles.red}&gt;...&lt;/Col&gt; &lt;Col&gt;...&lt;/Col&gt; &lt;Col className={styles.red}&gt;...&lt;/Col&gt; &lt;/Row&gt; &lt;/div&gt; &lt;div className={styles.middle}&gt; &lt;Row justify=&quot;center&quot; align=&quot;middle&quot; className={styles.row3}&gt; &lt;img src={back3} className={styles.back3} /&gt; &lt;span className={styles.row3Text}&gt;...&lt;/span&gt; &lt;/Row&gt; &lt;Row justify=&quot;space-between&quot;&gt; {content.map((item, index) =&gt; ( &lt;Col style={{ cursor: 'pointer' }} span={6} onClick={() =&gt; run({ index })} &gt; &lt;div className={styles.contentItem}&gt; &lt;img src={item.src} className={styles.back4} /&gt; &lt;div className={styles.itemTitle}&gt;{item.title}&lt;/div&gt; &lt;div className={styles.itemDesc}&gt;{item.desc}&lt;/div&gt; &lt;/div&gt; &lt;/Col&gt; ))} &lt;/Row&gt; &lt;/div&gt; &lt;/div&gt; &lt;ColorFooter color=&quot;#B83900&quot; /&gt; &lt;/div&gt; &lt;/Spin&gt; &lt;Modal title=&quot;...&quot; footer={ &lt;Button type=&quot;primary&quot;&gt; ... &lt;/Button&gt; } onCancel={() =&gt; setVisible(false)} visible={visible} className={styles.modal} &gt; &lt;Row className={styles.modalRow}&gt;...&lt;/Row&gt; &lt;Row className={styles.modalRow}&gt;...&lt;/Row&gt; &lt;Row className={styles.modalRow}&gt; ... &lt;/Row&gt; &lt;/Modal&gt; &lt;/div&gt; 合理使用useStateuseState的本质是生成了一个包含对象还有更新方法的数组，这种生成\b开销是极其微小的，同时会随着组件的生命周期而自动回收，但是规范还是希望尽可能合并useState的使用，例如\b经典的开发场景就是一个Modal弹窗需要一个visible还很有可能需要一个editData。 eg: 123456&lt;Modal visible={visible}&gt; &lt;Form form={form} initialValues={editData}&gt; ...&lt;/Modal&gt; 此时往往会产生两个\buseState 12const [visible,setVisible] = useState(false);const [editData,setEditData] = useState(); 优化后 1const [edit,setEdit] = useState({visible:false,editData:undefined}) 同时需要非常注意useState的闭包陷阱，React的机制为了保证useState的值不会跟随render过程被销毁，在其内部保存了state的引用关系，而后会跟随链式关系更新数据，这就导致了\b如果在state中的值不是基础数据类型则很有可能触发闭包陷阱,解决方法也是众多，希望开发人员使用时多加注意⚠️ 页面组件规范页面组件往往承担着更为精细微小的工作，此时需要开发人员对其Props设置更为合理有效。 ❌: 12345interface ExpenseDrawerProps { sign: number; // ⬅️只能看出来需要一个number类型，具体要传什么值则完全无法体现 ...} ✅: 1234interface ExpenseDrawerProps { sign: 0 | 1; // 审核列表0 申请列表1 ...} 如果回调方法会根据类型判断返回值时 ❌: 12345678910export interface Props { type?: 'array' | 'number' onChange?:(value:array | number) =&gt; ...}A : React.FC&lt;Props&gt; = ...return &lt;A type='number' onChange={...}/&gt;// 此时A控件onChange就会因为类型推断为array类型或者number类型，但是此时我们明确要的是number类型 ✅: 123456789101112export interface INumber { value: number; onChange:number =&gt; ...}export interface IArray { value: string[]; onChange:string[] =&gt; ...}export interface Props = INumber | IArray... 因为页面组件往往是被包裹在路由组件中，而路由组件的操作会引起页面组件的刷新与重绘，所以建议将耗时操作放到外部的路由组件中，页面组件本身只根据状态展示页面 \b❌： 123456789101112131415161718const child:React.FC = props =&gt; { const {onSuccess} = props; const request = useRequest =&gt; onSuccess(data) return &lt;button loading onClick={request.run}&gt;}const Parent:React.FC = () =&gt; { return &lt;child onSuccess=data =&gt; ... /&gt;} ✅: 123456789101112131415161718const child:React.FC = props =&gt; { const {onSubmit} = props; return &lt;button loading onClick={onSubmit}&gt;}const Parent:React.FC = () =&gt; { const request = useRequest =&gt; onSuccess(data) return &lt;child onSubmit=request.run =&gt; ... /&gt;} 同时在页面组件中使用Context.Provider要\b充分考虑使用场景 \b❌： 123456789101112131415161718192021const ChildA1 = () =&gt; { const {data} = useContext(...)}const ChildA = () =&gt; { const {data} = useContext(...) return &lt;ChildA1&gt;}const Parent = () =&gt; { return &lt;Context...&gt;&lt;ChildA&gt;&lt;/Context&gt;} ✅： 123456789101112131415161718192021222324252627const ChildA = () =&gt; { const {data} = useContext(...)}const ChildB = () =&gt; { const {data} = useContext(...)}const ChildC = () =&gt; { const {data} = useContext(...)}const Parent = () =&gt; { return &lt;Context...&gt; &lt;ChildA&gt; &lt;ChildB&gt; &lt;ChildC&gt; &lt;/Context&gt;} 页面样式规范样式文件名希望统一为style.less，样式名称驼峰或者开启cameCase都可以 123456789101112.appBar { ... ...} ✅.app-bar{ ... ...} ✅ 碰到父组件和子组件都需要样式时尽量采用less的特性采用嵌套写法 123456789.parent{ ... ... .child{ ... ... }} 同时希望开发人员灵活运用css各种特性编写高质量的样式文件，规范不对此做强制限制。 config文件规范由Umi\b脚手架创建的项目会自动生成.umirc.ts文件，规范希望开发人员更多的采用/config/config.ts文件的方式，同时由于项目会分为Dev和Pro甚至更多运行环境，所以对文件名统一规范 config.ts文件在该文件中配置基础配置，如hash cssLoader local等项目环境变量 config.dev.ts文件测试环境文件，一般会在此文件中配置，打包目录outputPath以及一些定义在define中的变量 config.pro.ts文件正式环境文件，一般会在此文件中配置，打包目录outputPath以及一些定义在define中的变量 参考文档umi文档 求教一个 TypeScript 类型约束问题，如何根据一个条件生成约束？ 警惕React hooks中的闭包 团队 React 代码规范制定 2021最新阿里代码规范（前端篇）","link":"/wrh.github.io/2022/06/08/%E5%BC%A0%E6%8C%AF%E6%B0%91%E6%95%99%E8%82%B2%E7%A7%91%E6%8A%80%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"}],"tags":[],"categories":[]}