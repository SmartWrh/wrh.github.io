{"pages":[],"posts":[{"title":"张振民教育科技代码规范-01","text":"代码规范本身是为保证代码风格一致性和后期的可维护性，本规范主要参考了umi文档2021最新阿里代码规范（前端篇），考虑到目前各个项目人手都比较紧张，只有少数项目才有两人\b以上的共同开发，故文档不对常量名,变量名或文件名等做强制要求 项目框架所有项目都应该采用React+TypeScripe+Umi开发，后台类应用应采用Antd Pro,前端应用类使用脚手架Umi创建项目。 项目结构1234567891011121314151617src├── components└── pages ├── Welcome // 路由组件下不应该再包含其他路由组件，基于这个约定就能清楚的区分路由组件和非路由组件了 | ├── components // 对于复杂的页面可以再自己做更深层次的组织，但建议不要超过三层 | ├── Form.tsx | ├── index.tsx // 页面组件的代码 | └── index.less // 页面样式 ├── Order // 路由组件下不应该再包含其他路由组件，基于这个约定就能清楚的区分路由组件和非路由组件了 | ├── index.tsx | └── index.less ├── user // 一系列页面推荐通过小写的单一字母做 group 目录 | ├── components // group 下公用的组件集合 | ├── Login // group 下的页面 Login | ├── Register // group 下的页面 Register | └── util.ts // 这里可以有一些共用方法之类，不做推荐和约束，看业务场景自行做组织 └── * // 其它页面组件代码 所有路由组件（会配置在路由配置中的组件）我们推荐以大驼峰命名打平到 pages 下面第一级（复杂的项目可以增加 group 层级，在 group 下放置 pages）。不建议在路由组件内部再嵌套路由组件 - 不方便分辨一个组件是否是路由组件，而且不方便快速从全局定位到路由组件。我们推荐尽可能的拆分路由组件为更细粒度的组件，对于多个页面可能会用到的组件我们推荐放到 src/components 中，对于只是被单个页面依赖的（区块）组件，我们推荐就近维护到路由组件文件夹下即可。 注释规范整理需要加注释的地方 公共组件使用说明 api 目录的接口 非常见单词要加注释 涉及到一些运算方法应加注释 功能函数应加注释 eg: 12345678910111213141516171819function getTableId(index: number, data: T[]) { let sign = index; for (let i = 0; i &lt; data.length; i += 1) { const some = data.some(d =&gt; d.tableId === `add_${sign}`); if (some) sign += 1; else return `add_${sign}`; } return `add_${sign}`; }👆 不加注释完全无法理解👇 容易理解的多/** * 获取唯一ID,因为在列表中最初可能存在id 1，2，3 * 删除id 2时单纯根据下标赋id就会出现id 1，3，3 * 所以应该遍历数据源获取唯一ID */ function getTableId(index: number, data: T[]) { ... } 接口请求规范目前的项目中除了OA项目因为早期开发原因采用了dva方式请求接口，现在项目绝大部分工作场景都采用了ahooks中的\buseRequest请求接口，关于请求结果的返回类型，希望开发人员可以定义明确。 eg: 123456export interface IBudgetTotal { list: IBudget[] total: IApprovalTotal}const {run} = useRequest&lt;ZxRequestSingleData&lt;IBudgetTotal&gt;&gt;(mainBudget, {manual: true}); 如果出现接口只是用来确定,删除等操作不需要关注返回值的情况也可以不明确设定返回值。 eg: 12// 👇为导出表格接口const {run,} = useRequest&lt;ZxRequestSingleData&gt;(excelIn, {manual: true}) 还有个别情况使用了直接请求接口的方式，此时因为项目里面配置了errorConfig，所以在接口报错时依然会自动弹出错误信息，但是同时因为直接请求接口不会消费掉该异常，所以需要开发做好处理。 eg: 12345// 需要做好catch处理areaList() .then(...) .catch(() =&gt; ({})) .finally(...) 路由组件规范路由组件往往承担着非常重要的功能，所以规范希望可以尽可能在一个路由组件中拆分成更细微的页面组件。 eg: 12345&lt;AppControl.Provider value={value}&gt; &lt;Affix/&gt; &lt;ExamContent/&gt; &lt;CountDown /&gt;&lt;/AppControl.Provider&gt; 不建议: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;div className={styles.body}&gt; &lt;Spin spinning={loading}&gt; &lt;div className={styles.content}&gt; &lt;div className={styles.topper}&gt; &lt;img src={topBack} className={styles.topImg1} onClick={() =&gt; history.push('/home')} /&gt; &lt;/div&gt; &lt;div style={{ marginTop: '-150px' }}&gt; &lt;Row justify=&quot;center&quot;&gt; &lt;img src={back1} className={styles.back1} /&gt; &lt;/Row&gt; &lt;div className={styles.row2}&gt; &lt;img src={back2} className={styles.back2} /&gt; &lt;Row className={styles.textRow1}&gt; &lt;Col className={styles.pointer}&gt;01&lt;/Col&gt; &lt;Col&gt;...&lt;/Col&gt; &lt;Col className={styles.red}&gt;≥6个月&lt;/Col&gt; &lt;/Row&gt; &lt;Row className={styles.textRow2}&gt; &lt;Col className={styles.pointer}&gt;02&lt;/Col&gt; &lt;Col&gt;...&lt;/Col&gt; &lt;Col className={styles.red}&gt;...&lt;/Col&gt; &lt;Col&gt;...&lt;/Col&gt; &lt;Col className={styles.red}&gt;...&lt;/Col&gt; &lt;/Row&gt; &lt;/div&gt; &lt;div className={styles.middle}&gt; &lt;Row justify=&quot;center&quot; align=&quot;middle&quot; className={styles.row3}&gt; &lt;img src={back3} className={styles.back3} /&gt; &lt;span className={styles.row3Text}&gt;...&lt;/span&gt; &lt;/Row&gt; &lt;Row justify=&quot;space-between&quot;&gt; {content.map((item, index) =&gt; ( &lt;Col style={{ cursor: 'pointer' }} span={6} onClick={() =&gt; run({ index })} &gt; &lt;div className={styles.contentItem}&gt; &lt;img src={item.src} className={styles.back4} /&gt; &lt;div className={styles.itemTitle}&gt;{item.title}&lt;/div&gt; &lt;div className={styles.itemDesc}&gt;{item.desc}&lt;/div&gt; &lt;/div&gt; &lt;/Col&gt; ))} &lt;/Row&gt; &lt;/div&gt; &lt;/div&gt; &lt;ColorFooter color=&quot;#B83900&quot; /&gt; &lt;/div&gt; &lt;/Spin&gt; &lt;Modal title=&quot;...&quot; footer={ &lt;Button type=&quot;primary&quot;&gt; ... &lt;/Button&gt; } onCancel={() =&gt; setVisible(false)} visible={visible} className={styles.modal} &gt; &lt;Row className={styles.modalRow}&gt;...&lt;/Row&gt; &lt;Row className={styles.modalRow}&gt;...&lt;/Row&gt; &lt;Row className={styles.modalRow}&gt; ... &lt;/Row&gt; &lt;/Modal&gt; &lt;/div&gt; 合理使用useStateuseState的本质是生成了一个包含对象还有更新方法的数组，这种生成\b开销是极其微小的，同时会随着组件的生命周期而自动回收，但是规范还是希望尽可能合并useState的使用，例如\b经典的开发场景就是一个Modal弹窗需要一个visible还很有可能需要一个editData。 eg: 123456&lt;Modal visible={visible}&gt; &lt;Form form={form} initialValues={editData}&gt; ...&lt;/Modal&gt; 此时往往会产生两个\buseState 12const [visible,setVisible] = useState(false);const [editData,setEditData] = useState(); 优化后 1const [edit,setEdit] = useState({visible:false,editData:undefined}) 同时需要非常注意useState的闭包陷阱，React的机制为了保证useState的值不会跟随render过程被销毁，在其内部保存了state的引用关系，而后会跟随链式关系更新数据，这就导致了\b如果在state中的值不是基础数据类型则很有可能触发闭包陷阱,解决方法也是众多，希望开发人员使用时多加注意⚠️ 页面组件规范页面组件往往承担着更为精细微小的工作，此时需要开发人员对其Props设置更为合理有效。 ❌: 12345interface ExpenseDrawerProps { sign: number; // ⬅️只能看出来需要一个number类型，具体要传什么值则完全无法体现 ...} ✅: 1234interface ExpenseDrawerProps { sign: 0 | 1; // 审核列表0 申请列表1 ...} 如果回调方法会根据类型判断返回值时 ❌: 12345678910export interface Props { type?: 'array' | 'number' onChange?:(value:array | number) =&gt; ...}A : React.FC&lt;Props&gt; = ...return &lt;A type='number' onChange={...}/&gt;// 此时A控件onChange就会因为类型推断为array类型或者number类型，但是此时我们明确要的是number类型 ✅: 123456789101112export interface INumber { value: number; onChange:number =&gt; ...}export interface IArray { value: string[]; onChange:string[] =&gt; ...}export interface Props = INumber | IArray... 因为页面组件往往是被包裹在路由组件中，而路由组件的操作会引起页面组件的刷新与重绘，所以建议将耗时操作放到外部的路由组件中，页面组件本身只根据状态展示页面 \b❌： 123456789101112131415161718const child:React.FC = props =&gt; { const {onSuccess} = props; const request = useRequest =&gt; onSuccess(data) return &lt;button loading onClick={request.run}&gt;}const Parent:React.FC = () =&gt; { return &lt;child onSuccess=data =&gt; ... /&gt;} ✅: 123456789101112131415161718const child:React.FC = props =&gt; { const {onSubmit} = props; return &lt;button loading onClick={onSubmit}&gt;}const Parent:React.FC = () =&gt; { const request = useRequest =&gt; onSuccess(data) return &lt;child onSubmit=request.run =&gt; ... /&gt;} 同时在页面组件中使用Context.Provider要\b充分考虑使用场景 \b❌： 123456789101112131415161718192021const ChildA1 = () =&gt; { const {data} = useContext(...)}const ChildA = () =&gt; { const {data} = useContext(...) return &lt;ChildA1&gt;}const Parent = () =&gt; { return &lt;Context...&gt;&lt;ChildA&gt;&lt;/Context&gt;} ✅： 123456789101112131415161718192021222324252627const ChildA = () =&gt; { const {data} = useContext(...)}const ChildB = () =&gt; { const {data} = useContext(...)}const ChildC = () =&gt; { const {data} = useContext(...)}const Parent = () =&gt; { return &lt;Context...&gt; &lt;ChildA&gt; &lt;ChildB&gt; &lt;ChildC&gt; &lt;/Context&gt;} 页面样式规范样式文件名希望统一为style.less，样式名称驼峰或者开启cameCase都可以 123456789101112.appBar { ... ...} ✅.app-bar{ ... ...} ✅ 碰到父组件和子组件都需要样式时尽量采用less的特性采用嵌套写法 123456789.parent{ ... ... .child{ ... ... }} 同时希望开发人员灵活运用css各种特性编写高质量的样式文件，规范不对此做强制限制。 config文件规范由Umi\b脚手架创建的项目会自动生成.umirc.ts文件，规范希望开发人员更多的采用/config/config.ts文件的方式，同时由于项目会分为Dev和Pro甚至更多运行环境，所以对文件名统一规范 config.ts文件在该文件中配置基础配置，如hash cssLoader local等项目环境变量 config.dev.ts文件测试环境文件，一般会在此文件中配置，打包目录outputPath以及一些定义在define中的变量 config.pro.ts文件正式环境文件，一般会在此文件中配置，打包目录outputPath以及一些定义在define中的变量 参考文档umi文档 求教一个 TypeScript 类型约束问题，如何根据一个条件生成约束？ 警惕React hooks中的闭包 团队 React 代码规范制定 2021最新阿里代码规范（前端篇）","link":"/wrh.github.io/2022/06/08/%E5%BC%A0%E6%8C%AF%E6%B0%91%E6%95%99%E8%82%B2%E7%A7%91%E6%8A%80%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"},{"title":"张振民教育科技前端混合开发技术调研报告","text":"前期调研市场上的混合开发方案，大致包括 React Native Flutter Weex Ionic Native Script 经过比对产品社区活跃度，代码更新力度，官方维护速度，使用人数，目前我认为只有React Native或者Flutter可以被投放到生产环境。 项目 Github star 最后更新时间 中文社区 插件支持数量 发布时间 React Native 103k 2022-05-08 活跃 多 2015 Flutter 142k 2022-05-29 活跃 多 2017 Weex 17.9k 2021-05-24 一般 一般 2015 Ionic 47.4k 2022-06-01 无 多 2013 Native Script 21.3k 2022-06-05 无 一般 2015 React Native vs Flutter以下主要对RN（React Native以下简称RN）和 Flutter做比较。 搭建环境不论是RN还是Flutter在Windows系统上都没办法直接运行iOS环境,所以以下测试都是针对与Android端开发 RN 环境搭建需要 Node、JDK 和 Android Studio Android SDK Flutter 环境搭建需要 Android Studio Flutter SDK 代码上手难易度RN支持JavaScript或者TypeScript前端上手难度较小只需要熟悉RN本身的一些特有语法以及一些基础库还有路由堆栈的概念即可上手。 123456789101112131415161718192021import Icons from &quot;react-native-vector-icons/Feather&quot;import {createBottomTabNavigator,BottomTabBar} from &quot;react-navigation-tabs&quot;import {createAppContainer} from &quot;react-navigation&quot;import { StyleSheet, Image, } from &quot;react-native&quot;import HomePage from &quot;../page/HomePage&quot;import DevicePage from &quot;../page/DevicePage&quot;import MinePage from &quot;../page/MinePage&quot;import MessagePage from &quot;../page/MessagePage&quot;const Tabs = { Home:{ screen:HomePage, navigationOptions:{...} }, Device..., Message..., Mine...,}return Tabs; Flutter采用Dart语言，语言本身难度不算高甚至有些类似JavaScript,但是Dart语言结合Flutter开发刚上手时可能会对特有的嵌套写法产生很大的疑惑，而且Flutter嵌套式的写法对于调试放面可能也会造成一定的问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102class _CustomTheme extends InheritedWidget { final CustomThemeState data; _CustomTheme({this.data, Key key, @required Widget child}) : super(key: key, child: child); @override bool updateShouldNotify(InheritedWidget oldWidget) { // TODO: implement updateShouldNotify return true; }}class CustomTheme extends StatefulWidget { final Widget child; final MyThemeKeys initialThemeKey; const CustomTheme({Key key, this.initialThemeKey, this.child}) : super(key: key); @override CustomThemeState createState() =&gt; CustomThemeState(); static ThemeModel of(BuildContext context) { _CustomTheme inherited = (context.inheritFromWidgetOfExactType(_CustomTheme) as _CustomTheme); return inherited.data.theme; } static CustomThemeState instanceOf(BuildContext context) { _CustomTheme inherited = (context.inheritFromWidgetOfExactType(_CustomTheme) as _CustomTheme); return inherited.data; }}class CustomThemeState extends State&lt;CustomTheme&gt; { ThemeModel _model; ThemeModel get theme =&gt; _model; @override void initState() { _model = MyThemes.getThemeFromKey(widget.initialThemeKey); super.initState(); } void changeTheme(MyThemeKeys themeKey) { print(themeKey); setState(() { _model = MyThemes.getThemeFromKey(themeKey); }); } @override Widget build(BuildContext context) { return _CustomTheme(data: this, child: widget.child); }}enum MyThemeKeys { LIGHT, DARK }class MyThemes { static final ThemeModel lightTheme = ThemeModel( imageUrl: 'assets/images/banner.png', backgroundColor: Color(0xffffffff), titleColor: Color(0xff3C4859), borderColor: Colors.black.withOpacity(0.3), isDark: false); static final ThemeModel darkTheme = ThemeModel( imageUrl: 'assets/images/banner_dark.png', backgroundColor: Color(0xff2B1C71), titleColor: Color(0xffffffff), borderColor: Colors.white.withOpacity(0.3), isDark: true); static ThemeModel getThemeFromKey(MyThemeKeys themeKey) { switch (themeKey) { case MyThemeKeys.LIGHT: return lightTheme; case MyThemeKeys.DARK: return darkTheme; default: return lightTheme; } }}void main() { runApp(CustomTheme(initialThemeKey: MyThemeKeys.LIGHT, child: MyApp()));}class MyApp extends StatelessWidget { Widget build(BuildContext context) { return MaterialApp( title: 'Flutter Demo', debugShowCheckedModeBanner: false, home: HomePage()); }} 跨平台实现原理 对于原生 Android 或者 Compose 而言，是「原生代码经过 skia 最后到 GPU 完成渲染绘制」，Android 原生系统本身自带了 skia； 对于 Flutter 而言，「Dart 代码里的控件经过 skia 最后到 GPU 完成渲染绘制」，这里在 Andriod 上使用的系统的 skia ，而在 iOS 上使用的是打包到项目里的 skia ； 对于 ReactNative/Weex 等类似的项目，它们是「运行在各自的 JS 引擎里面，最后通过映射为原生的控件，利用原生的渲染能力进行渲染」； 从理论上来说「Flutter 在实现上是最接近原生，因为从实现路径上基本是一致的，而 RN/Weex 相对会差一些，但是因为Flutter的特性，如果碰到重大问题很有可能只能依赖与官方的更新与修复，而React等还可通过强行写原生代码交互来规避修复重大问题。 应用构建大小应用打包生成的最终大小会受到平台以及是否开启压缩混淆等限制，大概情况为Flutter在Android端大小最小,但在iOS端又会比RN大,空项目打包大小如下 项目 Android iOS React Native 2.5m windows无法构建 Flutter 2.3m 4.7m 最后总节与个人建议关于Flutter与RN我都已经实际上手运行，两个项目都有各自的优劣势 项目 难度 性能 调试 跨平台 热更新 踩坑解决方案 RN 简单 中高 不方便 ios/Android社区中有插件支持web 支持 最差的结果可能需要写原生代码 Flutter 中等 理论上无限接近原生 不方便 ios/Androidweb/macOS/windows 社区插件支持 需要等待官方修复 Flutter支持的跨平台更多，性能方面也理论上接近原生开发，但是Flutter的跨平台方案整体还存在一定的不确定性，我个人的建议还是RN会更稳妥一点。 参考文档Flutter Festival | 2022 年 Flutter 适合我吗？Flutter VS Other 量化对比 2022年06月07日了，跨平台开发框架现在怎样了？ 2022 年移动开发的最佳 React Native 替代方案 年终盘点跨平台技术优劣势对比（Hybrid、RN、Weex、Flutter）","link":"/wrh.github.io/2022/06/08/%E5%89%8D%E7%AB%AF%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E8%B0%83%E6%9F%A5%E6%8A%A5%E5%91%8A/"},{"title":"张振民教育科技前端学习资料","text":"前端学习路线 一些前端学习资料 ReactReact 英文官网，最新的api文档以及最新的Demo示例，中文官网有更新不及时的情况 facebook/react github地址可以clone代码来自己调试源码 React 基础与进阶 掘金上系统分析React源码的专栏 React Hooks 最佳实践 网易云音乐分享的一篇基础hooks实践 kutt 一个开源的React项目 React Router React Router官网 React 全部 Hooks 使用大全 （包含 React v18 版本 ） React_Fiber机制 你应该在 React 中传递 Promise Hooks 之 useTransition、useDeferredValue 奇怪，useMemo依赖没变，回调还会反复执行？ React 如何实现代码分割（Code Splitting） 🚀 从 create-react-app 迁移到 vite ⚡️ React Fiber不就是个链表么 「React深入」一文吃透虚拟DOM和diff算法 是时候放弃redux了，zustand是完美替代者 前端性能优化——首页资源压缩63%、白屏时间缩短86% TypeScript中的React高阶组件 React中的这个TS骚操作秀到我了 在 React 中自定义 Hooks 的应用场景 深入了解 React Fiber 内部实现 可能是最详细的React组件库搭建总结 React Hooks 详解 【近 1W 字】+ 项目实战 JavaScript/TypeScript你从不理解闭包，直到你要去面试 1.2w字深入理解JavaScript26个核心概念 面试官再问call、apply、bind。来来来、我给你手写一个！ 18个有用的JavaScript片段 JS数组奇巧淫技 都2020年了，你还不会JavaScript 装饰器？ 1.2W字 | 了不起的 TypeScript 入门教程 type 和 interface 傻傻分不清楚？ 用了 TS 映射类型，同事直呼内行！ JavaScript 中如何实现并发控制？ 图解设计模式之观察者模式（TypeScript） Typescript 实践中的命令模式 CSSSVG基础及其动画应用浅析 2022 年移动端适配方案指南 — 全网最新最全 十分钟教你用svg做出精美的动画！ 现代 CSS 解决方案：CSS 原生支持的三角函数 现代图片性能优化及体验优化指南 CSS 高阶小技巧 - 角向渐变的妙用！ vh 存在问题？试试动态视口单位之 dvh、svh、lvh 现代 CSS 指南 – at-rule 规则扫盲 新时代布局新特性 – 容器查询 浅谈逻辑选择器 – 父选择器它来了！ 革命性创新，动画杀手锏 @scroll-timeline 深入浅出 CSS 动画 CSS @property，让不可能变可能 你不能只会flex居中布局，精制动画讲解所有flex布局方式！通俗易懂纯干货教程！ 熟练了Flex布局之后，该学学Grid布局了 你未必知道的49个CSS知识点 10 个 GitHub 上超火的 CSS 奇技淫巧项目，找到写 CSS 的灵感！ 改善 CSS 的 10 个最佳实践 我写CSS的常用套路 妙用CSS变量，让你的CSS变得更心动 其他Webpack 详解 当面试官问Webpack的时候他想知道什么 🔥【万字】透过分析 webpack 面试题，构建 webpack5.x 知识体系 深入浅出 Vite Vite 3.0 正式发布，下一代前端构建工具！ 漫谈构建工具(四): 为什么有人说 vite 快，有人却说 vite 慢？ pnpm 是凭什么对 npm 和 yarn 降维打击的 关于现代包管理器的深度思考——为什么现在我更推荐 pnpm 而不是 npm/yarn? pnpm快到碗里来！ 🚀Turborepo：发布当月就激增 3.8k Star，这款超神的新兴 Monorepo 方案，你不打算尝试下吗？ Turborepo: 是时候给你的monorepo仓库上上对抗了 你会用ES6，那倒是用啊！ ES6、ES7、ES8、ES9、ES10新特性一览 JS正则表达式完整教程（略长） 记好这 24 个 ES6 方法，用来解决实际开发的 JS 问题 学习网站掘金 思否 CSDN github ….","link":"/wrh.github.io/2023/08/23/%E5%BC%A0%E6%8C%AF%E6%B0%91%E6%95%99%E8%82%B2%E7%A7%91%E6%8A%80%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"title":"Sentry异常分类","text":"Sentry应该关注的点更多的应该聚焦在崩溃率，Sentry上的异常是多种多样的有自定义的异常统计也有Sentry本身捕获到的异常，具体观察异常的时候通常需要开发人员的参与。目前Sentry中的bk项目为听力前端异常监控。 自定义异常bk项目中的自定义异常目前有两个 接口http异常 接口业务异常 接口http异常的逻辑是指本身的http请求异常，如接口超时，接口404，接口403，服务器宕机等非正常的http请求结果会上报Sentry，这时需要后端的同事参与进行修复，需要注意的是如果是用户的终端设备本身断网也会统计，此时需要根据具体情况具体分析。 接口业务异常的逻辑是指接口返回了不符合约定的code码，约定的数据接口格式为 123456{ code: 200, data: ..., msg: &quot;请求成功&quot;, success: true,} 如果有接口返回的code和约定的不一致则会上报Sentry，此时也需要后端的同事参与进行修复，需要注意的是有些接口返回不符合约定的code是正常情况，如登录超时，验证码错误等，此时需要根据具体情况具体分析。 Sentry捕获的异常Sentry中捕获异常的逻辑为全局捕获Error信息并上报，所以在上报的异常中并不代表所以异常都会导致程序崩溃白屏，往往需要根据上报次数和影响人数来区分优先级 异常可大致分为: 恶行bug会导致程序崩溃白屏，此类异常往往可以根据发生次数和影响人数来判断，还可以根据Sentry中有没有精确的代码捕获来判断是否是此类异常 过低版本浏览器引发的bug，此类异常往往是由于本身浏览器或微信版本过低，没有提供一些必要的方法，判断此类异常需要具体分析设备的版本以及报错信息 浏览器本身的报错信息，由于Sentry是全部捕获Error信息所以会导致浏览器本身抛出的异常信息也会统计上报，此类异常往往是发生次数极低影响用户极少，需要根据错误信息具体分析 资源加载的报错信息，目前的音频文件因为本身需要浏览器的播放器支持，所以如果资源本身出现问题导致的播放问题也会统计上报 解决方法: 恶行bug的特性是传播多，影响大，同时也相对容易定位，解决办法通常是修复掉具体的异常代码块即可 过低版本浏览器导致的问题，需要具体分析，有些问题可以通过手动打包添加相对应的polyfill来适配低版本浏览器，有些问题则客观上无法解决。 浏览器本身的问题，无法通过前端的代码来进行修复。 资源加载的问题可以通过和后端同事的配合来进行相应的解决，但无法从根本上解决此类问题。","link":"/wrh.github.io/2023/09/11/Sentry%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB/"},{"title":"前端通用组件化方案报告","text":"引言随着Web技术的不断发展，前端开发已经进入了组件化时代。组件化开发可以提高开发效率，降低维护成本，使得前端代码更具有可重用性和可扩展性。本报告旨在探讨一种通用的前端组件化方案，以便适应不同的项目需求和技术栈。 需求分析随着项目增多发现现在多个项目中有一些重复的场景可以被封装为组件复用,也有一些重复的逻辑可以被封装为通用库,包括不限于: 不同项目的接口请求逻辑可以被复用 不同项目的异常处理逻辑可以被复用 听力前后端和试卷网项目的视频播放组件 听力前后端移动版和PC版音频播放组件 不同项目的图片上传组件 试卷网后台和蚂蚁云盘的批量上传逻辑 通用的树结构数据处理逻辑 … 封装的通用组件目标: 可供React、微信小程序场景接入 满足逻辑封装和组合的需求，具备易用的编程模型，包括但不仅限于数据驱动视图、响应式数据、事件、生命周期、以及父子组件通信所需要的props和emit特性。 具备Context API、状态管理、TS支持 方案考略到需要兼容React以及微信小程序同时微信小程序是使用taro框架编写，封装的组件库应该使用React语言编写。 除了代码语言外还应该考略的问题有以下几点: 组件库本身如何快速迭代开发？ 前端项目如何方便简单的安装封装的组件库? 开发人员如何快速的上手组件库，如何压平前端的上手学习曲线？ 如何不重复制造轮子？ 结合公司实际情况以及目前市面上已有的方案有如下解决办法: 组件库本身如何快速迭代开发？ 组件库本身也是作为一个项目来搭建的配合gitlab和一些开源方案如dumi、VitePress、Rspack就和开发普通的前端项目一样，迭代起来也是非常方便。 前端项目如何方便简单的安装封装的组件库? 考略到要支持React以及微信小程序代码必然要抹平平台间的差异，所以代码本身一定是需要对不同平台做出不同处理，如果还是按照平时的开发习惯可能会导致大量的耦合代码出现，应该采用类似现在流行的Multi repo方式开发，采用这种方式开发的知名项目有react和Vue等等，采用这种方式开发可以使用Turbo repo这个框架来加速编译的过程。 开发人员如何快速的上手组件库，如何压平前端的上手学习曲线 应该构建好完善的开发文档可以采用上述介绍过构建工具大致效果如下: 上述效果是采用dumi完成 如何不重复制造轮子？ 封装通用组件库的核心逻辑是在与节省开发过程中的部分重复工作量，并不是在于封装这一过程，如果已经有现成的解决方案如ProTable、ProModal等珠玉在前的方案开发过程中不应再过多封装这些场景。 封装的组件本身应该做好封装,继承,多态,抽象,举一个例子 上传图片的组件我们开发过程中不能只考虑上传的过程，应该同时考略到上传成功后的回调,上传失败的回调，上传验证的问题，以及批量上传，或者上传了文件类型等非图片格式。 缺点一个事件有好处的同时必然也伴随着许多劣势，是否采用要在于取舍，封装通用组件库的劣势有如下几点 组件库升级不方便，如上传图片最开始只支持一次性上传9张图片，现在有新需求期望支持更多的图片，需要先更新组件库代码并且打包发布，然后开发在升级该库才能完成需求。 有沟通成本，A开发的组件库B在使用，B有新需求需要再和A沟通后由A打包发布B再验证代码。如果需求未完成还需继续沟通。 有维护成本，目前没有专门维护组件库的人员，如果都参与到组件库的开发同时碰到自身有项目开发的时候必然导致维护成本增加","link":"/wrh.github.io/2023/10/23/%E5%89%8D%E7%AB%AF%E7%BB%84%E4%BB%B6%E5%8C%96%E6%8A%A5%E5%91%8A/"},{"title":"SEO（搜索引擎优化）","text":"引言 SEO（搜索引擎优化）对网站和在线业务有许多好处，包括： 提高网站流量： 通过在搜索引擎中获得更高的排名，可以增加网站的曝光度并吸引更多的访问者，从而增加网站的流量。 提高品牌曝光度： 在搜索引擎中排名较高可以增加品牌的可见性和曝光度，让更多的用户了解您的品牌和业务。 增加潜在客户和销售机会： 通过吸引更多的有意向的访问者，您可以增加潜在客户和销售机会，从而增加收入和利润。 降低营销成本： 相较于付费广告等营销渠道，SEO的长期投资回报率（ROI）通常更高。一旦您的网站达到了良好的排名，您就可以持续地吸引流量而无需额外的广告支出。 增强用户体验： 优化网站以提高其在搜索引擎中的排名通常也会改善用户体验。例如，改善网站的加载速度、优化移动端体验等都有助于提高用户满意度。 建立品牌信任和权威性： 在搜索引擎中排名较高通常被认为是品牌的信任和权威的象征，因此有助于建立用户对品牌的信任和认可。 持续性： 一旦您的网站达到了良好的排名，它将会持续吸引流量并为您带来潜在客户，而不像付费广告一样需要持续投入。 SEO可以帮助提高网站的可见性、流量和销售机会，同时也可以降低营销成本并增强用户体验，是在线业务成功的重要因素之一，所以基于上述的原因决心提高优化王朝霞试卷网SEO曝光能力。 可以从以下几点入手优化： 关键词匹配： 百度会根据用户的搜索关键词来匹配网站的内容。因此，网站的标题、Meta标签、页面内容等应该与用户搜索的关键词相关联，但要注意避免过度堆砌关键词。 内容质量： 百度更倾向于显示内容丰富、原创和有价值的网站。提供有用的信息、解决用户问题的内容以及高质量的多媒体内容都可能提高网站在百度的排名。 网站权威性： 百度会评估网站的权威性和可信度，这一评估主要是通过外部链接的数量和质量来确定的。拥有来自高权威网站的外部链接将有助于提高网站在百度的排名。 用户体验： 百度重视用户体验，因此网站的加载速度、移动友好性、页面布局和导航等方面的优化都可以影响网站的排名。 页面质量： 网站的页面质量也是一个重要因素。百度可能会评估页面的排版、文字质量、图片质量等方面来确定页面的质量。 社交信号： 百度也可能考虑社交媒体上的分享和评论等社交信号来评估网站的影响力和受欢迎程度。 关键词匹配目前王朝霞试卷网关键词匹配做的亟待提升 首页首页得关键词keyword和description比较合理，是对试卷网得描述信息，关键字中带有试卷等重要关键字 详情页12345678&lt;meta name=&quot;description&quot; content=&quot;...&quot;&gt;&lt;meta name=&quot;keywords&quot; content=&quot;...&quot;&gt;&lt;meta data-react-helmet=&quot;true&quot; name=&quot;description&quot; content=&quot;...&quot;&gt;&lt;meta data-react-helmet=&quot;true&quot; name=&quot;keywords&quot; content=&quot;...&quot;&gt; 此时相当于同时存在description以及keywords 如果同时存在，搜索引擎通常会优先考虑&lt;meta name=&quot;description&quot; content=&quot;Your description here&quot;&gt;这种常见的描述元数据，因为这是 HTML 规范中明确定义的元数据格式之一。 所有页面都要注意description和keywords是否重复，以及应该符合产品经理设置得规则。 内容质量 价值： 内容应该对目标受众有实际的价值和意义。它可以提供信息、解决问题、回答疑问、提供娱乐等。 相关性： 内容应该与网站的主题或业务领域相关。与目标受众的兴趣和需求相符合的内容更容易被搜索引擎和用户发现和喜欢。 准确性： 内容应该是准确和可信的。不准确的信息可能会损害用户信任度，并对网站的权威性产生负面影响。 原创性： 原创性内容是指未经过复制或抄袭的内容。搜索引擎更倾向于显示原创性内容，并且对于排名较高的网站，原创性内容通常也是一个重要因素。 多样性： 内容应该丰富多样，包括文字、图片、视频、图表等形式，以满足不同用户的需求和偏好。 可读性： 内容应该易于理解和阅读，使用清晰的语言和逻辑结构，并避免拼写错误、语法错误等。 持续更新： 不断更新和维护内容可以提高网站的权威性和可信度，同时也有助于吸引新的访问者和保留现有用户。 网站权威性 百度会评估网站的权威性和可信度，这一评估主要是通过外部链接的数量和质量来确定的。拥有来自高权威网站的外部链接将有助于提高网站在百度的排名 现阶段我们可以通过和云书智联等项目设置外链提高王朝霞试卷网得权威性，如果可以与其他公司得网站互相设置外联则效果更好。 用户体验用户体验上我们应该持续优化加载速度以及针对SEO得布局优化。 如应该使用main、header、footer、nav、article、section等标签来替代普通得div。 这些新标签为开发人员提供更多的选择和辅助特性。 默认情况下，浏览器呈现这些新标签的方式与div相似。然而，合理地使用它们，可以使你的标签更加的语义化。辅助技术（如：屏幕阅读器）可以通过这些标签为用户提供更加准确的、易于理解的页面信息。 页面质量在页面质量上应该尤其注意a标签得href以及img得alt等属性 目前存在大量得a标签href是一段JavaScript，导致搜索引擎不会继续抓取网页。 同时对标签得切换也应该使用a标签得同时改变链接参数。 如图应该使用a标签，同时切换时应该改变url，如home?id=xxx方便搜索引擎持续抓取。 img标签没有设置alt 可点击区域应该为a标签 结论针对王朝霞试卷网PC版本得优化应该分如下几步来进行。 检查页面是否重复设置了无效得keywords以及description 云书智联等网站加入王朝霞试卷网外链 改造页面主体使用main、header、footer、nav、article、section等语义化标签 使用a标签并且注意href得使用，尤其注意需要跳转得地方以及修改url keywords以及description修改难度较低约 1~2天左右可以修改完毕 云书智联等网站加入王朝霞试卷网外链，修改难度较低约 1~2天左右可以修改完毕 改造页面内容繁多需要重新进行UI走查，需要10天左右 优化a标签img标签等，内容繁多并且有一定业务逻辑得改动需要重新进行功能测试需要14天左右 以上王朝霞试卷网PC版本优化如果是单人开发需要28天左右可以优化完毕上线 目标上述提升改造完成后希望数据可以提升10%以上，如果去年数据为4w改造后应提升为4w5左右 小程序SEO方案基本情况分析小程序现在本身基于Taro框架开发，如果需要支持SSR功能需要采用插件tarojs-plugin-ssr。 插件功能本质为Taro Code -&gt; Next Code -&gt; SSR 基于插件功能把代码转为Next，然后通过Next功能打包编译为NodeJs项目。 目前解决方案得难点 无法保证最新版Next 需要学习熟练使用Next框架 现有代码不能无缝转换到Next 影响后续开发 需要现有迭代暂停等SSR版本完整调试完毕 tarojs-plugin-ssr插件得核心功能是把Taro框架得代码转为Next框架代码，所以如果Next单方面升级了一些新语法或者新功能，必须等tarojs-plugin-ssr框架适配，如果需要自己fork框架修改则需要大量时间来学习该插件得源码(1~2月) 如果SSR需要一些配置则需要熟练掌握Next框架配置方案（2~4周） 现有代码部分组件内使用了原子化写法，转为Next框架时需要统一替换，此处需要大量时间以及重新测试(大约1月)12345import './index.less';&lt;div class='flex margin24'/&gt; 因为SSR服务端渲染需要在返回页面时就把数据填充完成，此处需要修改之前项目request接口时机，后续开发需要服务端渲染得页面都需要按此要求来修改，把现有需要服务端渲染得页面请求修改需要(大约3周左右时间) 因为SSR服务端渲染运行在Node.js环境，因此window与docment、localstorage等浏览器API无法访问，代码需要兼容Node.js环境 基于上述三点如果现有需求不断迭代则耽误整体改造进度（所有页面都需要修改./index.less使用方式，部分页面需要修改request方法），所以应该把迭代暂停全力改造项目为SSR 结论 现有迭代需要暂停 对于tarojs-plugin-ssr插件源码和Next.js的熟悉程度会影响项目改造进度 工期如果按照一人来算包括学习tarojs-plugin-ssr插件源码则需要大约12周 如果需要四个前端同时不包括学习tarojs-plugin-ssr插件源码则需要4~6周，修改期间业务迭代要暂停 三人开发需要7~8周 保证项目进度的情况下，尽量边做边学 耗时任务主要在于 老代码中的原子化样式写法需要改为CSS Module，此处暂时没有批量处理的方法 老代码中的request请求需要改造，此处肯定没有批量处理的方法 老代码中的token登录逻辑需要修改为cookie，此功能需要测试重新测试流程 老代码中的结构改造，如可以从以下几点入手优化","link":"/wrh.github.io/2024/04/09/SEO/"},{"title":"豆包与快对分析","text":"拆解豆包与快对的功能流程与截图，通过抓包工具分析对比了两者的实现方案，以及加载速度，在主观体验上进行了一个对比。最后对可能的用到的技术进行了分析。 APP 框题 框题速度 批改 答案 体验 豆包 ❌只能自动框选大题 ✅平均在300ms ❌基本上没有批改功能 ✅答案准确，识别上可能有瑕疵 ❌批改体验非常一般 快对 ✅大题小题都能框选 ❌平均在1.5s ✅批改效果良好 ✅答案准确，但是有可能失败失败 ✅体验良好 一. 豆包拍照批改分析前言豆包本身是作为一个AI工具存在的，所以其自带的拍题答疑或者是插件提供的批改作业都是依据一个AI工具的对话流存在的，体验性上差强人意，以下为具体分析自带的拍题答疑和批改作业。 拍题答疑 豆包本身自带的拍题答疑是作为其对话流中的一个小插件，其完整的工作流程如下 功能流程与截图 框题⭐⭐⭐⭐☆ 经过测试不同的科目的卷子以及长度不同的试题豆包都能很准确的框选住试题，默认是单题模式如果有三道题都在选框中时会以中间那道题为准，并且框题速度极快 切换至多题模式时也会很精准的把当前图像中的试题全部框选 经过抓包豆包App分析更多数据如下: 框题速度平均不到300毫秒 通过https://api-normal.doubao.com/hippo/turing/qs/v1/algorithm_detection接口上传图片并获取后台返回的题目坐标 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154{ &quot;TraceId&quot;: &quot;1838857193744633&quot;, &quot;RpcCode&quot;: 0, &quot;ElapsedTime&quot;: 31, &quot;QuestionBoxes&quot;: [ [ { &quot;Pos&quot;: [ { &quot;x&quot;: 94, &quot;y&quot;: 238 }, { &quot;x&quot;: 610, &quot;y&quot;: 236 }, { &quot;x&quot;: 610, &quot;y&quot;: 481 }, { &quot;x&quot;: 95, &quot;y&quot;: 483 } ], &quot;RotatedBoxData&quot;: { &quot;center&quot;: { &quot;x&quot;: 352, &quot;y&quot;: 360 }, &quot;width&quot;: 515.390625, &quot;height&quot;: 244.86328125, &quot;theta&quot;: -0.0027923583984375 }, &quot;HorizontalBoxData&quot;: { &quot;topLeft&quot;: { &quot;x&quot;: 94, &quot;y&quot;: 236 }, &quot;bottomRight&quot;: { &quot;x&quot;: 610, &quot;y&quot;: 483 }, &quot;class&quot;: 0, &quot;score&quot;: 0.94287109375 }, &quot;ColumnIndex&quot;: 0, &quot;PieceIndex&quot;: 0 }, { &quot;Pos&quot;: [ { &quot;x&quot;: 88, &quot;y&quot;: 489 }, { &quot;x&quot;: 615, &quot;y&quot;: 490 }, { &quot;x&quot;: 615, &quot;y&quot;: 580 }, { &quot;x&quot;: 87, &quot;y&quot;: 579 } ], &quot;RotatedBoxData&quot;: { &quot;center&quot;: { &quot;x&quot;: 351, &quot;y&quot;: 535 }, &quot;width&quot;: 527.34375, &quot;height&quot;: 89.47265625, &quot;theta&quot;: 0.002239227294921875 }, &quot;HorizontalBoxData&quot;: { &quot;topLeft&quot;: { &quot;x&quot;: 87, &quot;y&quot;: 489 }, &quot;bottomRight&quot;: { &quot;x&quot;: 615, &quot;y&quot;: 580 }, &quot;class&quot;: 0, &quot;score&quot;: 0.91650390625 }, &quot;ColumnIndex&quot;: 0, &quot;PieceIndex&quot;: 0 }, { &quot;Pos&quot;: [ { &quot;x&quot;: 80, &quot;y&quot;: 585 }, { &quot;x&quot;: 626, &quot;y&quot;: 588 }, { &quot;x&quot;: 625, &quot;y&quot;: 679 }, { &quot;x&quot;: 80, &quot;y&quot;: 676 } ], &quot;RotatedBoxData&quot;: { &quot;center&quot;: { &quot;x&quot;: 353, &quot;y&quot;: 632 }, &quot;width&quot;: 545.625, &quot;height&quot;: 90.703125, &quot;theta&quot;: 0.00537872314453125 }, &quot;HorizontalBoxData&quot;: { &quot;topLeft&quot;: { &quot;x&quot;: 80, &quot;y&quot;: 585 }, &quot;bottomRight&quot;: { &quot;x&quot;: 626, &quot;y&quot;: 679 }, &quot;class&quot;: 0, &quot;score&quot;: 0.90234375 }, &quot;ColumnIndex&quot;: 0, &quot;PieceIndex&quot;: 0 } ] ], &quot;CentralBoxIndexList&quot;: [ 0 ], &quot;image_orientation&quot;: 0, &quot;HandWrittenRemovalBase64&quot;: &quot;&quot;, &quot;isStorageBase64&quot;: false, &quot;ImageDewarpBase64&quot;: &quot;&quot;, &quot;detection_id&quot;: 1838857193857418, &quot;status_info&quot;: { &quot;status_code&quot;: 0, &quot;status_msg&quot;: &quot;success&quot;, &quot;toast_msg&quot;: &quot;&quot;, &quot;err_tips&quot;: &quot;&quot;, &quot;server_time&quot;: 1753670877, &quot;extra&quot;: null }} 此时已经把所有题目框选出来并返回到QuestionBoxes数组中 确认题目后通过https://api-normal.doubao.com/im/sse/send/message?flow_im_arch=v2接口把选中的题目裁切成图片又传给后端进行流式输出 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970{ &quot;channel&quot;: 3, &quot;cmd&quot;: 100, &quot;sequence_id&quot;: &quot;9ae60f44-c677-43f5-b64a-b0932c6e4810&quot;, &quot;uplink_body&quot;: { &quot;send_message_body&quot;: { &quot;ack_only&quot;: false, &quot;applet_payload&quot;: { &quot;current_system_volume&quot;: &quot;0.33&quot;, &quot;vui_media_player_scene&quot;: &quot;&quot;, &quot;vui_media_player_occupied&quot;: &quot;0&quot;, &quot;client_system_permission&quot;: &quot;{\\&quot;notification\\&quot;:\\&quot;1\\&quot;,\\&quot;microphone\\&quot;:\\&quot;0\\&quot;}&quot;, &quot;is_app_background&quot;: &quot;0&quot;, &quot;is_douyin_installed&quot;: &quot;0&quot;, &quot;is_luna_installed&quot;: &quot;0&quot;, &quot;media_player_business_scene&quot;: &quot;&quot;, &quot;record_status&quot;: &quot;1&quot; }, &quot;bot_id&quot;: &quot;7234781073513644036&quot;, &quot;bot_type&quot;: 1, &quot;client_controller_param&quot;: { &quot;answer_with_suggest&quot;: true, &quot;local_language_code&quot;: &quot;zh&quot;, &quot;local_nickname&quot;: &quot;wrh&quot;, &quot;local_voice_id&quot;: &quot;104&quot; }, &quot;content&quot;: &quot;{\\&quot;image_list\\&quot;:[{\\&quot;image_ori\\&quot;:{\\&quot;height\\&quot;:244,\\&quot;width\\&quot;:515},\\&quot;key\\&quot;:\\&quot;tos-cn-i-a9rns2rl98/bot-chat-image/970d5ffa9b2d45fd9842d4eed7965e9c\\&quot;,\\&quot;local_res_path\\&quot;:\\&quot;/storage/emulated/0/Android/data/com.larus.nova/files/images/sendimages/camera_250728_110903_44549.jpeg\\&quot;}],\\&quot;src\\&quot;:\\&quot;user-sent\\&quot;}&quot;, &quot;content_type&quot;: 6, &quot;conversation_id&quot;: &quot;13553022762660866&quot;, &quot;conversation_type&quot;: 3, &quot;create_time&quot;: 1753672145, &quot;ext&quot;: { &quot;tts&quot;: &quot;1&quot;, &quot;create_time_ms&quot;: &quot;1753672145358&quot;, &quot;record_status&quot;: &quot;1&quot;, &quot;wiki&quot;: &quot;2&quot;, &quot;search_engine_type&quot;: &quot;4&quot;, &quot;media_search_type&quot;: &quot;1&quot;, &quot;answer_with_suggest&quot;: &quot;1&quot;, &quot;system_language&quot;: &quot;zh&quot;, &quot;camera_data_source&quot;: &quot;1&quot;, &quot;Copilot:hippo:hippo_ext&quot;: &quot;{\\&quot;data\\&quot;:\\&quot;{\\\\\\&quot;os\\\\\\&quot;:2,\\\\\\&quot;edu_camera_sdk_version\\\\\\&quot;:\\\\\\&quot;10400\\\\\\&quot;,\\\\\\&quot;picture_source\\\\\\&quot;:1,\\\\\\&quot;detection_type\\\\\\&quot;:1,\\\\\\&quot;detection_id\\\\\\&quot;:1838858518575193,\\\\\\&quot;user_change_boxes\\\\\\&quot;:[false],\\\\\\&quot;detection_scene_type\\\\\\&quot;:101}\\&quot;,\\&quot;to_module_unit\\&quot;:[{\\&quot;to_module\\&quot;:4}]}&quot;, &quot;action_bar_instruction_type&quot;: &quot;7&quot;, &quot;action_bar_key&quot;: &quot;coco_instruction&quot;, &quot;action_bar_instruction&quot;: &quot;{\\&quot;ext\\&quot;:{\\&quot;music_gen_style_select\\&quot;:\\&quot;\\&quot;,\\&quot;music_lyrics_format\\&quot;:\\&quot;\\&quot;,\\&quot;music_lyrics_help_me_writing_format\\&quot;:\\&quot;\\&quot;,\\&quot;replica_auto_popup\\&quot;:\\&quot;1\\&quot;},\\&quot;input_box_content\\&quot;:{\\&quot;reply_message_format\\&quot;:\\&quot;\\&quot;,\\&quot;user_input_content\\&quot;:\\&quot;\\&quot;},\\&quot;instruction_item_list\\&quot;:[],\\&quot;instruction_type\\&quot;:7,\\&quot;menu_conf\\&quot;:{\\&quot;item_list\\&quot;:[]},\\&quot;persistent\\&quot;:false,\\&quot;starling_name\\&quot;:\\&quot;image_search_btn\\&quot;,\\&quot;use_template_id\\&quot;:\\&quot;\\&quot;}&quot;, &quot;camera_type&quot;: &quot;edu&quot;, &quot;is_from_edu_continue_shot&quot;: &quot;0&quot;, &quot;upload_file_click_from&quot;: &quot;camera_page_icon&quot;, &quot;is_manual_input&quot;: &quot;false&quot;, &quot;ugc_plugin_auth_infos&quot;: &quot;[]&quot;, &quot;is_app_background&quot;: &quot;0&quot;, &quot;is_douyin_installed&quot;: &quot;0&quot;, &quot;is_luna_installed&quot;: &quot;0&quot;, &quot;media_player_business_scene&quot;: &quot;&quot;, &quot;need_deep_think&quot;: &quot;2&quot;, &quot;need_net_search&quot;: &quot;0&quot;, &quot;send_message_scene&quot;: &quot;shoot&quot; }, &quot;client_fallback_param&quot;: { &quot;last_section_id&quot;: &quot;13936717231139842&quot;, &quot;last_message_index&quot;: 34 }, &quot;local_message_id&quot;: &quot;9ae60f44-c677-43f5-b64a-b0932c6e4810&quot;, &quot;sender_id&quot;: &quot;1690396828115395&quot;, &quot;status&quot;: 0, &quot;unique_key&quot;: &quot;7a0245a3-d621-469f-b7e2-bff3f87fd39d&quot; } }, &quot;version&quot;: &quot;1&quot;} 批改 ⭐⭐☆☆☆ 拍题答疑本身是基本不具备正常的批改体验的，而是直接输出答案和答案解析 批改速度 ⭐⭐⭐☆☆ 批改输出的速度比较一般，应该是受到还需要重新上传图片影响，平均需要6秒左右 答案结果正确性 ⭐⭐⭐⭐⭐ 答案结果准确无误应该是拆录的答案文件，和试卷本身提供的答案一模一样 批改作业 批改作业作为豆包的一个AI插件补足了一些豆包批改的功能，但是整体逻辑依然是基于豆包的AI对话流程来展现的 功能流程与截图 框题☆☆☆☆☆ 没有任何自动框题的功能，支持手动框题，但是手动框题结束后依然会输出拍摄的全部内容 批改 ⭐⭐⭐☆☆ 批改比豆包的拍题答疑多了一些关于答案的对错判断，但是由于是基于对话流来呈现的体验上依然非常差。 批改速度 ⭐⭐⭐☆☆ 批改的核心接口依然是基于豆包的https://api-normal.doubao.com/im/sse/send/message速度和豆包保持一致 答案结果正确性 ⭐⭐⭐⭐⭐ 答案和试卷本身提供的答案一致，推测和豆包数据源一致。 特色功能 由于其基础的批改功能丧失，并没有什么特殊功能。 二. 快对批改分析前言快对AI本身是专攻作业批改、搜题答疑、拍照翻译相关，其中作业批改的用户体验极佳，其UI界面，产品逻辑都有很多值得参考的方面。 功能流程与截图 框题⭐⭐⭐⭐⭐ 框题十分准确，大题和小题都能框选，并且对于错题和正确的题目在UI界面上一眼就能区分，体验十分好。 经过抓包快对App分析更多数据如下: 框题速度平均在1.5秒 POST https://pigai.kuaiduizuoye.com/pigai/submit/correctsearch HTTP/1.1 接口返回结果如下，数据经过精简 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152{&quot;errNo&quot;: 0,&quot;errstr&quot;: &quot;success&quot;,&quot;data&quot;: {&quot;sid&quot;: &quot;de659f9eded657f741b2075d8687683094c99d5a5425520d&quot;,&quot;isHandWring&quot;: 1,&quot;rotateAngle&quot;: 0,&quot;statisticsInfo&quot;: {},&quot;courseId&quot;: 1,&quot;titlebarContent&quot;: &quot;批改完成，点击图片查看解析&quot;,&quot;pigaiList&quot;: [{&quot;coordinate&quot;: {},&quot;screenshotCoordinate&quot;: {},&quot;index&quot;: 0,&quot;style&quot;: 900,&quot;expType&quot;: 2,&quot;errorFormula&quot;: &quot;&quot;,&quot;correctFormula&quot;: &quot;&quot;,&quot;question&quot;: &quot;&quot;,&quot;type&quot;: 2,&quot;isShow&quot;: 1,&quot;rotate&quot;: 0,&quot;isHandWring&quot;: 1,&quot;answerList&quot;: [],&quot;commentResult&quot;: [],&quot;qid&quot;: 0,&quot;isCraLatex&quot;: 0,&quot;calRightAnswer&quot;: &quot;&quot;,&quot;pval&quot;: 0,&quot;pid&quot;: &quot;&quot;,&quot;tag&quot;: 0,&quot;judgeCategory&quot;: &quot;&quot;,&quot;pvalNLabel&quot;: 0,&quot;pvalLabel&quot;: 1,&quot;judgeExt&quot;: null},...],&quot;pageId&quot;: &quot;zyb_a6d173355b45588bce1f872b752eb1fe&quot;,&quot;ocrJson&quot;: &quot;&quot;,&quot;bookPageId&quot;: &quot;&quot;,&quot;imageInfo&quot;: {},&quot;arithBookInfo&quot;: {},&quot;humanCorrectInfo&quot;: {},&quot;wholePageInfo&quot;: {},&quot;npsInfo&quot;: {},&quot;validatedInfo&quot;: &quot;&quot;,&quot;delay&quot;: 0}} 批改 ⭐⭐⭐⭐☆ 批改能准确输出答案，并且可以指出回答错误的原因 但是也有识别错误匹配成完全不相关题目的现象出现 经过抓包发现快对中的批改结果页是采用内嵌webView来实现的 GET https://www.kuaiduizuoye.com/static/hy/kd-result-main/pigai-4fad14cd-hycache.html?parentModel=0&amp;token=1_XPXQH3c5HRPtFHkSwi3sCCURmT25QfxM&amp;vc=1370&amp;channel=huawei&amp;_dc=0.6081031388801773&amp;vcname=6.68.0&amp;cuid=B9E32FD3EF01D1308F5783A6ACFB92AA|0&amp;os=android&amp;province=&amp;city=&amp;area=&amp;appId=scancode&amp;appid=scancode&amp;lat=0&amp;lon=0&amp;pad=1&amp;screen=vertical&amp;padAb=0&amp;newui=1&amp;t=1753772737776 HTTP/1.1 批改速度 ⭐⭐⭐⭐☆ 经过抓包工具分析，批改结果页面应该是由多个webview拼接来实现的，合并起来时间不超过1秒 答案结果正确性 ⭐⭐⭐⭐☆ 快对的逻辑应该是有拆录的试卷和答案，如果能成功匹配到则结果准确无误 如果匹配不到的话，目前看会强行匹配一个答案，很容易造成答案南辕北辙的情况 特色功能 目前体验下来有文档矫正，AI对话等功能，可以针对错题不理解的题目继续于AI对话来深度交流。 可能使用到的方案LayoutLM系列模型 Microsoft开源的文档理解模型 能够同时理解文本内容和版面结构 适合复杂文档的结构化分析 YOLOv8/YOLOv9 用于检测题目框、选择题选项、填空题区域等 可以训练自定义的试卷元素检测模型 RapidFuzz 适合大量答案批改场景。","link":"/wrh.github.io/2025/07/25/%E6%8B%8D%E7%85%A7%E6%89%B9%E6%94%B9%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/"}],"tags":[{"name":"前端","slug":"前端","link":"/wrh.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Flutter","slug":"Flutter","link":"/wrh.github.io/tags/Flutter/"},{"name":"ReactNative","slug":"ReactNative","link":"/wrh.github.io/tags/ReactNative/"}],"categories":[{"name":"公司文档","slug":"公司文档","link":"/wrh.github.io/categories/%E5%85%AC%E5%8F%B8%E6%96%87%E6%A1%A3/"},{"name":"代码规范","slug":"代码规范","link":"/wrh.github.io/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"调研报告","slug":"调研报告","link":"/wrh.github.io/categories/%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/"},{"name":"混合开发","slug":"混合开发","link":"/wrh.github.io/categories/%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/"}]}