{"pages":[],"posts":[{"title":"张振民教育科技代码规范-01","text":"代码规范本身是为保证代码风格一致性和后期的可维护性，本规范主要参考了umi文档2021最新阿里代码规范（前端篇），考虑到目前各个项目人手都比较紧张，只有少数项目才有两人\b以上的共同开发，故文档不对常量名,变量名或文件名等做强制要求 项目框架所有项目都应该采用React+TypeScripe+Umi开发，后台类应用应采用Antd Pro,前端应用类使用脚手架Umi创建项目。 项目结构1234567891011121314151617src├── components└── pages ├── Welcome // 路由组件下不应该再包含其他路由组件，基于这个约定就能清楚的区分路由组件和非路由组件了 | ├── components // 对于复杂的页面可以再自己做更深层次的组织，但建议不要超过三层 | ├── Form.tsx | ├── index.tsx // 页面组件的代码 | └── index.less // 页面样式 ├── Order // 路由组件下不应该再包含其他路由组件，基于这个约定就能清楚的区分路由组件和非路由组件了 | ├── index.tsx | └── index.less ├── user // 一系列页面推荐通过小写的单一字母做 group 目录 | ├── components // group 下公用的组件集合 | ├── Login // group 下的页面 Login | ├── Register // group 下的页面 Register | └── util.ts // 这里可以有一些共用方法之类，不做推荐和约束，看业务场景自行做组织 └── * // 其它页面组件代码 所有路由组件（会配置在路由配置中的组件）我们推荐以大驼峰命名打平到 pages 下面第一级（复杂的项目可以增加 group 层级，在 group 下放置 pages）。不建议在路由组件内部再嵌套路由组件 - 不方便分辨一个组件是否是路由组件，而且不方便快速从全局定位到路由组件。我们推荐尽可能的拆分路由组件为更细粒度的组件，对于多个页面可能会用到的组件我们推荐放到 src/components 中，对于只是被单个页面依赖的（区块）组件，我们推荐就近维护到路由组件文件夹下即可。 注释规范整理需要加注释的地方 公共组件使用说明 api 目录的接口 非常见单词要加注释 涉及到一些运算方法应加注释 功能函数应加注释 eg: 12345678910111213141516171819function getTableId(index: number, data: T[]) { let sign = index; for (let i = 0; i &lt; data.length; i += 1) { const some = data.some(d =&gt; d.tableId === `add_${sign}`); if (some) sign += 1; else return `add_${sign}`; } return `add_${sign}`; }👆 不加注释完全无法理解👇 容易理解的多/** * 获取唯一ID,因为在列表中最初可能存在id 1，2，3 * 删除id 2时单纯根据下标赋id就会出现id 1，3，3 * 所以应该遍历数据源获取唯一ID */ function getTableId(index: number, data: T[]) { ... } 接口请求规范目前的项目中除了OA项目因为早期开发原因采用了dva方式请求接口，现在项目绝大部分工作场景都采用了ahooks中的\buseRequest请求接口，关于请求结果的返回类型，希望开发人员可以定义明确。 eg: 123456export interface IBudgetTotal { list: IBudget[] total: IApprovalTotal}const {run} = useRequest&lt;ZxRequestSingleData&lt;IBudgetTotal&gt;&gt;(mainBudget, {manual: true}); 如果出现接口只是用来确定,删除等操作不需要关注返回值的情况也可以不明确设定返回值。 eg: 12// 👇为导出表格接口const {run,} = useRequest&lt;ZxRequestSingleData&gt;(excelIn, {manual: true}) 还有个别情况使用了直接请求接口的方式，此时因为项目里面配置了errorConfig，所以在接口报错时依然会自动弹出错误信息，但是同时因为直接请求接口不会消费掉该异常，所以需要开发做好处理。 eg: 12345// 需要做好catch处理areaList() .then(...) .catch(() =&gt; ({})) .finally(...) 路由组件规范路由组件往往承担着非常重要的功能，所以规范希望可以尽可能在一个路由组件中拆分成更细微的页面组件。 eg: 12345&lt;AppControl.Provider value={value}&gt; &lt;Affix/&gt; &lt;ExamContent/&gt; &lt;CountDown /&gt;&lt;/AppControl.Provider&gt; 不建议: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;div className={styles.body}&gt; &lt;Spin spinning={loading}&gt; &lt;div className={styles.content}&gt; &lt;div className={styles.topper}&gt; &lt;img src={topBack} className={styles.topImg1} onClick={() =&gt; history.push('/home')} /&gt; &lt;/div&gt; &lt;div style={{ marginTop: '-150px' }}&gt; &lt;Row justify=&quot;center&quot;&gt; &lt;img src={back1} className={styles.back1} /&gt; &lt;/Row&gt; &lt;div className={styles.row2}&gt; &lt;img src={back2} className={styles.back2} /&gt; &lt;Row className={styles.textRow1}&gt; &lt;Col className={styles.pointer}&gt;01&lt;/Col&gt; &lt;Col&gt;...&lt;/Col&gt; &lt;Col className={styles.red}&gt;≥6个月&lt;/Col&gt; &lt;/Row&gt; &lt;Row className={styles.textRow2}&gt; &lt;Col className={styles.pointer}&gt;02&lt;/Col&gt; &lt;Col&gt;...&lt;/Col&gt; &lt;Col className={styles.red}&gt;...&lt;/Col&gt; &lt;Col&gt;...&lt;/Col&gt; &lt;Col className={styles.red}&gt;...&lt;/Col&gt; &lt;/Row&gt; &lt;/div&gt; &lt;div className={styles.middle}&gt; &lt;Row justify=&quot;center&quot; align=&quot;middle&quot; className={styles.row3}&gt; &lt;img src={back3} className={styles.back3} /&gt; &lt;span className={styles.row3Text}&gt;...&lt;/span&gt; &lt;/Row&gt; &lt;Row justify=&quot;space-between&quot;&gt; {content.map((item, index) =&gt; ( &lt;Col style={{ cursor: 'pointer' }} span={6} onClick={() =&gt; run({ index })} &gt; &lt;div className={styles.contentItem}&gt; &lt;img src={item.src} className={styles.back4} /&gt; &lt;div className={styles.itemTitle}&gt;{item.title}&lt;/div&gt; &lt;div className={styles.itemDesc}&gt;{item.desc}&lt;/div&gt; &lt;/div&gt; &lt;/Col&gt; ))} &lt;/Row&gt; &lt;/div&gt; &lt;/div&gt; &lt;ColorFooter color=&quot;#B83900&quot; /&gt; &lt;/div&gt; &lt;/Spin&gt; &lt;Modal title=&quot;...&quot; footer={ &lt;Button type=&quot;primary&quot;&gt; ... &lt;/Button&gt; } onCancel={() =&gt; setVisible(false)} visible={visible} className={styles.modal} &gt; &lt;Row className={styles.modalRow}&gt;...&lt;/Row&gt; &lt;Row className={styles.modalRow}&gt;...&lt;/Row&gt; &lt;Row className={styles.modalRow}&gt; ... &lt;/Row&gt; &lt;/Modal&gt; &lt;/div&gt; 合理使用useStateuseState的本质是生成了一个包含对象还有更新方法的数组，这种生成\b开销是极其微小的，同时会随着组件的生命周期而自动回收，但是规范还是希望尽可能合并useState的使用，例如\b经典的开发场景就是一个Modal弹窗需要一个visible还很有可能需要一个editData。 eg: 123456&lt;Modal visible={visible}&gt; &lt;Form form={form} initialValues={editData}&gt; ...&lt;/Modal&gt; 此时往往会产生两个\buseState 12const [visible,setVisible] = useState(false);const [editData,setEditData] = useState(); 优化后 1const [edit,setEdit] = useState({visible:false,editData:undefined}) 同时需要非常注意useState的闭包陷阱，React的机制为了保证useState的值不会跟随render过程被销毁，在其内部保存了state的引用关系，而后会跟随链式关系更新数据，这就导致了\b如果在state中的值不是基础数据类型则很有可能触发闭包陷阱,解决方法也是众多，希望开发人员使用时多加注意⚠️ 页面组件规范页面组件往往承担着更为精细微小的工作，此时需要开发人员对其Props设置更为合理有效。 ❌: 12345interface ExpenseDrawerProps { sign: number; // ⬅️只能看出来需要一个number类型，具体要传什么值则完全无法体现 ...} ✅: 1234interface ExpenseDrawerProps { sign: 0 | 1; // 审核列表0 申请列表1 ...} 如果回调方法会根据类型判断返回值时 ❌: 12345678910export interface Props { type?: 'array' | 'number' onChange?:(value:array | number) =&gt; ...}A : React.FC&lt;Props&gt; = ...return &lt;A type='number' onChange={...}/&gt;// 此时A控件onChange就会因为类型推断为array类型或者number类型，但是此时我们明确要的是number类型 ✅: 123456789101112export interface INumber { value: number; onChange:number =&gt; ...}export interface IArray { value: string[]; onChange:string[] =&gt; ...}export interface Props = INumber | IArray... 因为页面组件往往是被包裹在路由组件中，而路由组件的操作会引起页面组件的刷新与重绘，所以建议将耗时操作放到外部的路由组件中，页面组件本身只根据状态展示页面 \b❌： 123456789101112131415161718const child:React.FC = props =&gt; { const {onSuccess} = props; const request = useRequest =&gt; onSuccess(data) return &lt;button loading onClick={request.run}&gt;}const Parent:React.FC = () =&gt; { return &lt;child onSuccess=data =&gt; ... /&gt;} ✅: 123456789101112131415161718const child:React.FC = props =&gt; { const {onSubmit} = props; return &lt;button loading onClick={onSubmit}&gt;}const Parent:React.FC = () =&gt; { const request = useRequest =&gt; onSuccess(data) return &lt;child onSubmit=request.run =&gt; ... /&gt;} 同时在页面组件中使用Context.Provider要\b充分考虑使用场景 \b❌： 123456789101112131415161718192021const ChildA1 = () =&gt; { const {data} = useContext(...)}const ChildA = () =&gt; { const {data} = useContext(...) return &lt;ChildA1&gt;}const Parent = () =&gt; { return &lt;Context...&gt;&lt;ChildA&gt;&lt;/Context&gt;} ✅： 123456789101112131415161718192021222324252627const ChildA = () =&gt; { const {data} = useContext(...)}const ChildB = () =&gt; { const {data} = useContext(...)}const ChildC = () =&gt; { const {data} = useContext(...)}const Parent = () =&gt; { return &lt;Context...&gt; &lt;ChildA&gt; &lt;ChildB&gt; &lt;ChildC&gt; &lt;/Context&gt;} 页面样式规范样式文件名希望统一为style.less，样式名称驼峰或者开启cameCase都可以 123456789101112.appBar { ... ...} ✅.app-bar{ ... ...} ✅ 碰到父组件和子组件都需要样式时尽量采用less的特性采用嵌套写法 123456789.parent{ ... ... .child{ ... ... }} 同时希望开发人员灵活运用css各种特性编写高质量的样式文件，规范不对此做强制限制。 config文件规范由Umi\b脚手架创建的项目会自动生成.umirc.ts文件，规范希望开发人员更多的采用/config/config.ts文件的方式，同时由于项目会分为Dev和Pro甚至更多运行环境，所以对文件名统一规范 config.ts文件在该文件中配置基础配置，如hash cssLoader local等项目环境变量 config.dev.ts文件测试环境文件，一般会在此文件中配置，打包目录outputPath以及一些定义在define中的变量 config.pro.ts文件正式环境文件，一般会在此文件中配置，打包目录outputPath以及一些定义在define中的变量 参考文档umi文档 求教一个 TypeScript 类型约束问题，如何根据一个条件生成约束？ 警惕React hooks中的闭包 团队 React 代码规范制定 2021最新阿里代码规范（前端篇）","link":"/wrh.github.io/2022/06/08/%E5%BC%A0%E6%8C%AF%E6%B0%91%E6%95%99%E8%82%B2%E7%A7%91%E6%8A%80%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"},{"title":"张振民教育科技前端混合开发技术调研报告","text":"前期调研市场上的混合开发方案，大致包括 React Native Flutter Weex Ionic Native Script 经过比对产品社区活跃度，代码更新力度，官方维护速度，使用人数，目前我认为只有React Native或者Flutter可以被投放到生产环境。 项目 Github star 最后更新时间 中文社区 插件支持数量 发布时间 React Native 103k 2022-05-08 活跃 多 2015 Flutter 142k 2022-05-29 活跃 多 2017 Weex 17.9k 2021-05-24 一般 一般 2015 Ionic 47.4k 2022-06-01 无 多 2013 Native Script 21.3k 2022-06-05 无 一般 2015 React Native vs Flutter以下主要对RN（React Native以下简称RN）和 Flutter做比较。 搭建环境不论是RN还是Flutter在Windows系统上都没办法直接运行iOS环境,所以以下测试都是针对与Android端开发 RN 环境搭建需要 Node、JDK 和 Android Studio Android SDK Flutter 环境搭建需要 Android Studio Flutter SDK 代码上手难易度RN支持JavaScript或者TypeScript前端上手难度较小只需要熟悉RN本身的一些特有语法以及一些基础库还有路由堆栈的概念即可上手。 123456789101112131415161718192021import Icons from &quot;react-native-vector-icons/Feather&quot;import {createBottomTabNavigator,BottomTabBar} from &quot;react-navigation-tabs&quot;import {createAppContainer} from &quot;react-navigation&quot;import { StyleSheet, Image, } from &quot;react-native&quot;import HomePage from &quot;../page/HomePage&quot;import DevicePage from &quot;../page/DevicePage&quot;import MinePage from &quot;../page/MinePage&quot;import MessagePage from &quot;../page/MessagePage&quot;const Tabs = { Home:{ screen:HomePage, navigationOptions:{...} }, Device..., Message..., Mine...,}return Tabs; Flutter采用Dart语言，语言本身难度不算高甚至有些类似JavaScript,但是Dart语言结合Flutter开发刚上手时可能会对特有的嵌套写法产生很大的疑惑，而且Flutter嵌套式的写法对于调试放面可能也会造成一定的问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102class _CustomTheme extends InheritedWidget { final CustomThemeState data; _CustomTheme({this.data, Key key, @required Widget child}) : super(key: key, child: child); @override bool updateShouldNotify(InheritedWidget oldWidget) { // TODO: implement updateShouldNotify return true; }}class CustomTheme extends StatefulWidget { final Widget child; final MyThemeKeys initialThemeKey; const CustomTheme({Key key, this.initialThemeKey, this.child}) : super(key: key); @override CustomThemeState createState() =&gt; CustomThemeState(); static ThemeModel of(BuildContext context) { _CustomTheme inherited = (context.inheritFromWidgetOfExactType(_CustomTheme) as _CustomTheme); return inherited.data.theme; } static CustomThemeState instanceOf(BuildContext context) { _CustomTheme inherited = (context.inheritFromWidgetOfExactType(_CustomTheme) as _CustomTheme); return inherited.data; }}class CustomThemeState extends State&lt;CustomTheme&gt; { ThemeModel _model; ThemeModel get theme =&gt; _model; @override void initState() { _model = MyThemes.getThemeFromKey(widget.initialThemeKey); super.initState(); } void changeTheme(MyThemeKeys themeKey) { print(themeKey); setState(() { _model = MyThemes.getThemeFromKey(themeKey); }); } @override Widget build(BuildContext context) { return _CustomTheme(data: this, child: widget.child); }}enum MyThemeKeys { LIGHT, DARK }class MyThemes { static final ThemeModel lightTheme = ThemeModel( imageUrl: 'assets/images/banner.png', backgroundColor: Color(0xffffffff), titleColor: Color(0xff3C4859), borderColor: Colors.black.withOpacity(0.3), isDark: false); static final ThemeModel darkTheme = ThemeModel( imageUrl: 'assets/images/banner_dark.png', backgroundColor: Color(0xff2B1C71), titleColor: Color(0xffffffff), borderColor: Colors.white.withOpacity(0.3), isDark: true); static ThemeModel getThemeFromKey(MyThemeKeys themeKey) { switch (themeKey) { case MyThemeKeys.LIGHT: return lightTheme; case MyThemeKeys.DARK: return darkTheme; default: return lightTheme; } }}void main() { runApp(CustomTheme(initialThemeKey: MyThemeKeys.LIGHT, child: MyApp()));}class MyApp extends StatelessWidget { Widget build(BuildContext context) { return MaterialApp( title: 'Flutter Demo', debugShowCheckedModeBanner: false, home: HomePage()); }} 跨平台实现原理 对于原生 Android 或者 Compose 而言，是「原生代码经过 skia 最后到 GPU 完成渲染绘制」，Android 原生系统本身自带了 skia； 对于 Flutter 而言，「Dart 代码里的控件经过 skia 最后到 GPU 完成渲染绘制」，这里在 Andriod 上使用的系统的 skia ，而在 iOS 上使用的是打包到项目里的 skia ； 对于 ReactNative/Weex 等类似的项目，它们是「运行在各自的 JS 引擎里面，最后通过映射为原生的控件，利用原生的渲染能力进行渲染」； 从理论上来说「Flutter 在实现上是最接近原生，因为从实现路径上基本是一致的，而 RN/Weex 相对会差一些，但是因为Flutter的特性，如果碰到重大问题很有可能只能依赖与官方的更新与修复，而React等还可通过强行写原生代码交互来规避修复重大问题。 应用构建大小应用打包生成的最终大小会受到平台以及是否开启压缩混淆等限制，大概情况为Flutter在Android端大小最小,但在iOS端又会比RN大,空项目打包大小如下 项目 Android iOS React Native 2.5m windows无法构建 Flutter 2.3m 4.7m 最后总节与个人建议关于Flutter与RN我都已经实际上手运行，两个项目都有各自的优劣势 项目 难度 性能 调试 跨平台 热更新 踩坑解决方案 RN 简单 中高 不方便 ios/Android社区中有插件支持web 支持 最差的结果可能需要写原生代码 Flutter 中等 理论上无限接近原生 不方便 ios/Androidweb/macOS/windows 社区插件支持 需要等待官方修复 Flutter支持的跨平台更多，性能方面也理论上接近原生开发，但是Flutter的跨平台方案整体还存在一定的不确定性，我个人的建议还是RN会更稳妥一点。 参考文档Flutter Festival | 2022 年 Flutter 适合我吗？Flutter VS Other 量化对比 2022年06月07日了，跨平台开发框架现在怎样了？ 2022 年移动开发的最佳 React Native 替代方案 年终盘点跨平台技术优劣势对比（Hybrid、RN、Weex、Flutter）","link":"/wrh.github.io/2022/06/08/%E5%89%8D%E7%AB%AF%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E8%B0%83%E6%9F%A5%E6%8A%A5%E5%91%8A/"}],"tags":[{"name":"Flutter","slug":"Flutter","link":"/wrh.github.io/tags/Flutter/"},{"name":"ReactNative","slug":"ReactNative","link":"/wrh.github.io/tags/ReactNative/"},{"name":"前端","slug":"前端","link":"/wrh.github.io/tags/%E5%89%8D%E7%AB%AF/"}],"categories":[{"name":"公司文档","slug":"公司文档","link":"/wrh.github.io/categories/%E5%85%AC%E5%8F%B8%E6%96%87%E6%A1%A3/"},{"name":"调研报告","slug":"调研报告","link":"/wrh.github.io/categories/%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/"},{"name":"混合开发","slug":"混合开发","link":"/wrh.github.io/categories/%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/"},{"name":"代码规范","slug":"代码规范","link":"/wrh.github.io/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"}]}