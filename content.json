{"pages":[],"posts":[{"title":"张振民教育科技代码规范-01","text":"代码规范本身是为保证代码风格一致性和后期的可维护性，本规范主要参考了umi文档2021最新阿里代码规范（前端篇），考虑到目前各个项目人手都比较紧张，只有少数项目才有两人\b以上的共同开发，故文档不对常量名,变量名或文件名等做强制要求 项目框架所有项目都应该采用React+TypeScripe+Umi开发，后台类应用应采用Antd Pro,前端应用类使用脚手架Umi创建项目。 项目结构1234567891011121314151617src├── components└── pages ├── Welcome // 路由组件下不应该再包含其他路由组件，基于这个约定就能清楚的区分路由组件和非路由组件了 | ├── components // 对于复杂的页面可以再自己做更深层次的组织，但建议不要超过三层 | ├── Form.tsx | ├── index.tsx // 页面组件的代码 | └── index.less // 页面样式 ├── Order // 路由组件下不应该再包含其他路由组件，基于这个约定就能清楚的区分路由组件和非路由组件了 | ├── index.tsx | └── index.less ├── user // 一系列页面推荐通过小写的单一字母做 group 目录 | ├── components // group 下公用的组件集合 | ├── Login // group 下的页面 Login | ├── Register // group 下的页面 Register | └── util.ts // 这里可以有一些共用方法之类，不做推荐和约束，看业务场景自行做组织 └── * // 其它页面组件代码 所有路由组件（会配置在路由配置中的组件）我们推荐以大驼峰命名打平到 pages 下面第一级（复杂的项目可以增加 group 层级，在 group 下放置 pages）。不建议在路由组件内部再嵌套路由组件 - 不方便分辨一个组件是否是路由组件，而且不方便快速从全局定位到路由组件。我们推荐尽可能的拆分路由组件为更细粒度的组件，对于多个页面可能会用到的组件我们推荐放到 src/components 中，对于只是被单个页面依赖的（区块）组件，我们推荐就近维护到路由组件文件夹下即可。 注释规范整理需要加注释的地方 公共组件使用说明 api 目录的接口 非常见单词要加注释 涉及到一些运算方法应加注释 功能函数应加注释 eg: 12345678910111213141516171819function getTableId(index: number, data: T[]) { let sign = index; for (let i = 0; i &lt; data.length; i += 1) { const some = data.some(d =&gt; d.tableId === `add_${sign}`); if (some) sign += 1; else return `add_${sign}`; } return `add_${sign}`; }👆 不加注释完全无法理解👇 容易理解的多/** * 获取唯一ID,因为在列表中最初可能存在id 1，2，3 * 删除id 2时单纯根据下标赋id就会出现id 1，3，3 * 所以应该遍历数据源获取唯一ID */ function getTableId(index: number, data: T[]) { ... } 接口请求规范目前的项目中除了OA项目因为早期开发原因采用了dva方式请求接口，现在项目绝大部分工作场景都采用了ahooks中的\buseRequest请求接口，关于请求结果的返回类型，希望开发人员可以定义明确。 eg: 123456export interface IBudgetTotal { list: IBudget[] total: IApprovalTotal}const {run} = useRequest&lt;ZxRequestSingleData&lt;IBudgetTotal&gt;&gt;(mainBudget, {manual: true}); 如果出现接口只是用来确定,删除等操作不需要关注返回值的情况也可以不明确设定返回值。 eg: 12// 👇为导出表格接口const {run,} = useRequest&lt;ZxRequestSingleData&gt;(excelIn, {manual: true}) 还有个别情况使用了直接请求接口的方式，此时因为项目里面配置了errorConfig，所以在接口报错时依然会自动弹出错误信息，但是同时因为直接请求接口不会消费掉该异常，所以需要开发做好处理。 eg: 12345// 需要做好catch处理areaList() .then(...) .catch(() =&gt; ({})) .finally(...) 路由组件规范路由组件往往承担着非常重要的功能，所以规范希望可以尽可能在一个路由组件中拆分成更细微的页面组件。 eg: 12345&lt;AppControl.Provider value={value}&gt; &lt;Affix/&gt; &lt;ExamContent/&gt; &lt;CountDown /&gt;&lt;/AppControl.Provider&gt; 不建议: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;div className={styles.body}&gt; &lt;Spin spinning={loading}&gt; &lt;div className={styles.content}&gt; &lt;div className={styles.topper}&gt; &lt;img src={topBack} className={styles.topImg1} onClick={() =&gt; history.push('/home')} /&gt; &lt;/div&gt; &lt;div style={{ marginTop: '-150px' }}&gt; &lt;Row justify=&quot;center&quot;&gt; &lt;img src={back1} className={styles.back1} /&gt; &lt;/Row&gt; &lt;div className={styles.row2}&gt; &lt;img src={back2} className={styles.back2} /&gt; &lt;Row className={styles.textRow1}&gt; &lt;Col className={styles.pointer}&gt;01&lt;/Col&gt; &lt;Col&gt;...&lt;/Col&gt; &lt;Col className={styles.red}&gt;≥6个月&lt;/Col&gt; &lt;/Row&gt; &lt;Row className={styles.textRow2}&gt; &lt;Col className={styles.pointer}&gt;02&lt;/Col&gt; &lt;Col&gt;...&lt;/Col&gt; &lt;Col className={styles.red}&gt;...&lt;/Col&gt; &lt;Col&gt;...&lt;/Col&gt; &lt;Col className={styles.red}&gt;...&lt;/Col&gt; &lt;/Row&gt; &lt;/div&gt; &lt;div className={styles.middle}&gt; &lt;Row justify=&quot;center&quot; align=&quot;middle&quot; className={styles.row3}&gt; &lt;img src={back3} className={styles.back3} /&gt; &lt;span className={styles.row3Text}&gt;...&lt;/span&gt; &lt;/Row&gt; &lt;Row justify=&quot;space-between&quot;&gt; {content.map((item, index) =&gt; ( &lt;Col style={{ cursor: 'pointer' }} span={6} onClick={() =&gt; run({ index })} &gt; &lt;div className={styles.contentItem}&gt; &lt;img src={item.src} className={styles.back4} /&gt; &lt;div className={styles.itemTitle}&gt;{item.title}&lt;/div&gt; &lt;div className={styles.itemDesc}&gt;{item.desc}&lt;/div&gt; &lt;/div&gt; &lt;/Col&gt; ))} &lt;/Row&gt; &lt;/div&gt; &lt;/div&gt; &lt;ColorFooter color=&quot;#B83900&quot; /&gt; &lt;/div&gt; &lt;/Spin&gt; &lt;Modal title=&quot;...&quot; footer={ &lt;Button type=&quot;primary&quot;&gt; ... &lt;/Button&gt; } onCancel={() =&gt; setVisible(false)} visible={visible} className={styles.modal} &gt; &lt;Row className={styles.modalRow}&gt;...&lt;/Row&gt; &lt;Row className={styles.modalRow}&gt;...&lt;/Row&gt; &lt;Row className={styles.modalRow}&gt; ... &lt;/Row&gt; &lt;/Modal&gt; &lt;/div&gt; 合理使用useStateuseState的本质是生成了一个包含对象还有更新方法的数组，这种生成\b开销是极其微小的，同时会随着组件的生命周期而自动回收，但是规范还是希望尽可能合并useState的使用，例如\b经典的开发场景就是一个Modal弹窗需要一个visible还很有可能需要一个editData。 eg: 123456&lt;Modal visible={visible}&gt; &lt;Form form={form} initialValues={editData}&gt; ...&lt;/Modal&gt; 此时往往会产生两个\buseState 12const [visible,setVisible] = useState(false);const [editData,setEditData] = useState(); 优化后 1const [edit,setEdit] = useState({visible:false,editData:undefined}) 同时需要非常注意useState的闭包陷阱，React的机制为了保证useState的值不会跟随render过程被销毁，在其内部保存了state的引用关系，而后会跟随链式关系更新数据，这就导致了\b如果在state中的值不是基础数据类型则很有可能触发闭包陷阱,解决方法也是众多，希望开发人员使用时多加注意⚠️ 页面组件规范页面组件往往承担着更为精细微小的工作，此时需要开发人员对其Props设置更为合理有效。 ❌: 12345interface ExpenseDrawerProps { sign: number; // ⬅️只能看出来需要一个number类型，具体要传什么值则完全无法体现 ...} ✅: 1234interface ExpenseDrawerProps { sign: 0 | 1; // 审核列表0 申请列表1 ...} 如果回调方法会根据类型判断返回值时 ❌: 12345678910export interface Props { type?: 'array' | 'number' onChange?:(value:array | number) =&gt; ...}A : React.FC&lt;Props&gt; = ...return &lt;A type='number' onChange={...}/&gt;// 此时A控件onChange就会因为类型推断为array类型或者number类型，但是此时我们明确要的是number类型 ✅: 123456789101112export interface INumber { value: number; onChange:number =&gt; ...}export interface IArray { value: string[]; onChange:string[] =&gt; ...}export interface Props = INumber | IArray... 因为页面组件往往是被包裹在路由组件中，而路由组件的操作会引起页面组件的刷新与重绘，所以建议将耗时操作放到外部的路由组件中，页面组件本身只根据状态展示页面 \b❌： 123456789101112131415161718const child:React.FC = props =&gt; { const {onSuccess} = props; const request = useRequest =&gt; onSuccess(data) return &lt;button loading onClick={request.run}&gt;}const Parent:React.FC = () =&gt; { return &lt;child onSuccess=data =&gt; ... /&gt;} ✅: 123456789101112131415161718const child:React.FC = props =&gt; { const {onSubmit} = props; return &lt;button loading onClick={onSubmit}&gt;}const Parent:React.FC = () =&gt; { const request = useRequest =&gt; onSuccess(data) return &lt;child onSubmit=request.run =&gt; ... /&gt;} 同时在页面组件中使用Context.Provider要\b充分考虑使用场景 \b❌： 123456789101112131415161718192021const ChildA1 = () =&gt; { const {data} = useContext(...)}const ChildA = () =&gt; { const {data} = useContext(...) return &lt;ChildA1&gt;}const Parent = () =&gt; { return &lt;Context...&gt;&lt;ChildA&gt;&lt;/Context&gt;} ✅： 123456789101112131415161718192021222324252627const ChildA = () =&gt; { const {data} = useContext(...)}const ChildB = () =&gt; { const {data} = useContext(...)}const ChildC = () =&gt; { const {data} = useContext(...)}const Parent = () =&gt; { return &lt;Context...&gt; &lt;ChildA&gt; &lt;ChildB&gt; &lt;ChildC&gt; &lt;/Context&gt;} 页面样式规范样式文件名希望统一为style.less，样式名称驼峰或者开启cameCase都可以 123456789101112.appBar { ... ...} ✅.app-bar{ ... ...} ✅ 碰到父组件和子组件都需要样式时尽量采用less的特性采用嵌套写法 123456789.parent{ ... ... .child{ ... ... }} 同时希望开发人员灵活运用css各种特性编写高质量的样式文件，规范不对此做强制限制。 config文件规范由Umi\b脚手架创建的项目会自动生成.umirc.ts文件，规范希望开发人员更多的采用/config/config.ts文件的方式，同时由于项目会分为Dev和Pro甚至更多运行环境，所以对文件名统一规范 config.ts文件在该文件中配置基础配置，如hash cssLoader local等项目环境变量 config.dev.ts文件测试环境文件，一般会在此文件中配置，打包目录outputPath以及一些定义在define中的变量 config.pro.ts文件正式环境文件，一般会在此文件中配置，打包目录outputPath以及一些定义在define中的变量 参考文档umi文档 求教一个 TypeScript 类型约束问题，如何根据一个条件生成约束？ 警惕React hooks中的闭包 团队 React 代码规范制定 2021最新阿里代码规范（前端篇）","link":"/wrh.github.io/2022/06/08/%E5%BC%A0%E6%8C%AF%E6%B0%91%E6%95%99%E8%82%B2%E7%A7%91%E6%8A%80%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"},{"title":"张振民教育科技前端混合开发技术调研报告","text":"前期调研市场上的混合开发方案，大致包括 React Native Flutter Weex Ionic Native Script 经过比对产品社区活跃度，代码更新力度，官方维护速度，使用人数，目前我认为只有React Native或者Flutter可以被投放到生产环境。 项目 Github star 最后更新时间 中文社区 插件支持数量 发布时间 React Native 103k 2022-05-08 活跃 多 2015 Flutter 142k 2022-05-29 活跃 多 2017 Weex 17.9k 2021-05-24 一般 一般 2015 Ionic 47.4k 2022-06-01 无 多 2013 Native Script 21.3k 2022-06-05 无 一般 2015 React Native vs Flutter以下主要对RN（React Native以下简称RN）和 Flutter做比较。 搭建环境不论是RN还是Flutter在Windows系统上都没办法直接运行iOS环境,所以以下测试都是针对与Android端开发 RN 环境搭建需要 Node、JDK 和 Android Studio Android SDK Flutter 环境搭建需要 Android Studio Flutter SDK 代码上手难易度RN支持JavaScript或者TypeScript前端上手难度较小只需要熟悉RN本身的一些特有语法以及一些基础库还有路由堆栈的概念即可上手。 123456789101112131415161718192021import Icons from &quot;react-native-vector-icons/Feather&quot;import {createBottomTabNavigator,BottomTabBar} from &quot;react-navigation-tabs&quot;import {createAppContainer} from &quot;react-navigation&quot;import { StyleSheet, Image, } from &quot;react-native&quot;import HomePage from &quot;../page/HomePage&quot;import DevicePage from &quot;../page/DevicePage&quot;import MinePage from &quot;../page/MinePage&quot;import MessagePage from &quot;../page/MessagePage&quot;const Tabs = { Home:{ screen:HomePage, navigationOptions:{...} }, Device..., Message..., Mine...,}return Tabs; Flutter采用Dart语言，语言本身难度不算高甚至有些类似JavaScript,但是Dart语言结合Flutter开发刚上手时可能会对特有的嵌套写法产生很大的疑惑，而且Flutter嵌套式的写法对于调试放面可能也会造成一定的问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102class _CustomTheme extends InheritedWidget { final CustomThemeState data; _CustomTheme({this.data, Key key, @required Widget child}) : super(key: key, child: child); @override bool updateShouldNotify(InheritedWidget oldWidget) { // TODO: implement updateShouldNotify return true; }}class CustomTheme extends StatefulWidget { final Widget child; final MyThemeKeys initialThemeKey; const CustomTheme({Key key, this.initialThemeKey, this.child}) : super(key: key); @override CustomThemeState createState() =&gt; CustomThemeState(); static ThemeModel of(BuildContext context) { _CustomTheme inherited = (context.inheritFromWidgetOfExactType(_CustomTheme) as _CustomTheme); return inherited.data.theme; } static CustomThemeState instanceOf(BuildContext context) { _CustomTheme inherited = (context.inheritFromWidgetOfExactType(_CustomTheme) as _CustomTheme); return inherited.data; }}class CustomThemeState extends State&lt;CustomTheme&gt; { ThemeModel _model; ThemeModel get theme =&gt; _model; @override void initState() { _model = MyThemes.getThemeFromKey(widget.initialThemeKey); super.initState(); } void changeTheme(MyThemeKeys themeKey) { print(themeKey); setState(() { _model = MyThemes.getThemeFromKey(themeKey); }); } @override Widget build(BuildContext context) { return _CustomTheme(data: this, child: widget.child); }}enum MyThemeKeys { LIGHT, DARK }class MyThemes { static final ThemeModel lightTheme = ThemeModel( imageUrl: 'assets/images/banner.png', backgroundColor: Color(0xffffffff), titleColor: Color(0xff3C4859), borderColor: Colors.black.withOpacity(0.3), isDark: false); static final ThemeModel darkTheme = ThemeModel( imageUrl: 'assets/images/banner_dark.png', backgroundColor: Color(0xff2B1C71), titleColor: Color(0xffffffff), borderColor: Colors.white.withOpacity(0.3), isDark: true); static ThemeModel getThemeFromKey(MyThemeKeys themeKey) { switch (themeKey) { case MyThemeKeys.LIGHT: return lightTheme; case MyThemeKeys.DARK: return darkTheme; default: return lightTheme; } }}void main() { runApp(CustomTheme(initialThemeKey: MyThemeKeys.LIGHT, child: MyApp()));}class MyApp extends StatelessWidget { Widget build(BuildContext context) { return MaterialApp( title: 'Flutter Demo', debugShowCheckedModeBanner: false, home: HomePage()); }} 跨平台实现原理 对于原生 Android 或者 Compose 而言，是「原生代码经过 skia 最后到 GPU 完成渲染绘制」，Android 原生系统本身自带了 skia； 对于 Flutter 而言，「Dart 代码里的控件经过 skia 最后到 GPU 完成渲染绘制」，这里在 Andriod 上使用的系统的 skia ，而在 iOS 上使用的是打包到项目里的 skia ； 对于 ReactNative/Weex 等类似的项目，它们是「运行在各自的 JS 引擎里面，最后通过映射为原生的控件，利用原生的渲染能力进行渲染」； 从理论上来说「Flutter 在实现上是最接近原生，因为从实现路径上基本是一致的，而 RN/Weex 相对会差一些，但是因为Flutter的特性，如果碰到重大问题很有可能只能依赖与官方的更新与修复，而React等还可通过强行写原生代码交互来规避修复重大问题。 应用构建大小应用打包生成的最终大小会受到平台以及是否开启压缩混淆等限制，大概情况为Flutter在Android端大小最小,但在iOS端又会比RN大,空项目打包大小如下 项目 Android iOS React Native 2.5m windows无法构建 Flutter 2.3m 4.7m 最后总节与个人建议关于Flutter与RN我都已经实际上手运行，两个项目都有各自的优劣势 项目 难度 性能 调试 跨平台 热更新 踩坑解决方案 RN 简单 中高 不方便 ios/Android社区中有插件支持web 支持 最差的结果可能需要写原生代码 Flutter 中等 理论上无限接近原生 不方便 ios/Androidweb/macOS/windows 社区插件支持 需要等待官方修复 Flutter支持的跨平台更多，性能方面也理论上接近原生开发，但是Flutter的跨平台方案整体还存在一定的不确定性，我个人的建议还是RN会更稳妥一点。 参考文档Flutter Festival | 2022 年 Flutter 适合我吗？Flutter VS Other 量化对比 2022年06月07日了，跨平台开发框架现在怎样了？ 2022 年移动开发的最佳 React Native 替代方案 年终盘点跨平台技术优劣势对比（Hybrid、RN、Weex、Flutter）","link":"/wrh.github.io/2022/06/08/%E5%89%8D%E7%AB%AF%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E8%B0%83%E6%9F%A5%E6%8A%A5%E5%91%8A/"},{"title":"张振民教育科技前端学习资料","text":"前端学习路线 一些前端学习资料 ReactReact 英文官网，最新的api文档以及最新的Demo示例，中文官网有更新不及时的情况 facebook/react github地址可以clone代码来自己调试源码 React 基础与进阶 掘金上系统分析React源码的专栏 React Hooks 最佳实践 网易云音乐分享的一篇基础hooks实践 kutt 一个开源的React项目 React Router React Router官网 React 全部 Hooks 使用大全 （包含 React v18 版本 ） React_Fiber机制 你应该在 React 中传递 Promise Hooks 之 useTransition、useDeferredValue 奇怪，useMemo依赖没变，回调还会反复执行？ React 如何实现代码分割（Code Splitting） 🚀 从 create-react-app 迁移到 vite ⚡️ React Fiber不就是个链表么 「React深入」一文吃透虚拟DOM和diff算法 是时候放弃redux了，zustand是完美替代者 前端性能优化——首页资源压缩63%、白屏时间缩短86% TypeScript中的React高阶组件 React中的这个TS骚操作秀到我了 在 React 中自定义 Hooks 的应用场景 深入了解 React Fiber 内部实现 可能是最详细的React组件库搭建总结 React Hooks 详解 【近 1W 字】+ 项目实战 JavaScript/TypeScript你从不理解闭包，直到你要去面试 1.2w字深入理解JavaScript26个核心概念 面试官再问call、apply、bind。来来来、我给你手写一个！ 18个有用的JavaScript片段 JS数组奇巧淫技 都2020年了，你还不会JavaScript 装饰器？ 1.2W字 | 了不起的 TypeScript 入门教程 type 和 interface 傻傻分不清楚？ 用了 TS 映射类型，同事直呼内行！ JavaScript 中如何实现并发控制？ 图解设计模式之观察者模式（TypeScript） Typescript 实践中的命令模式 CSSSVG基础及其动画应用浅析 2022 年移动端适配方案指南 — 全网最新最全 十分钟教你用svg做出精美的动画！ 现代 CSS 解决方案：CSS 原生支持的三角函数 现代图片性能优化及体验优化指南 CSS 高阶小技巧 - 角向渐变的妙用！ vh 存在问题？试试动态视口单位之 dvh、svh、lvh 现代 CSS 指南 – at-rule 规则扫盲 新时代布局新特性 – 容器查询 浅谈逻辑选择器 – 父选择器它来了！ 革命性创新，动画杀手锏 @scroll-timeline 深入浅出 CSS 动画 CSS @property，让不可能变可能 你不能只会flex居中布局，精制动画讲解所有flex布局方式！通俗易懂纯干货教程！ 熟练了Flex布局之后，该学学Grid布局了 你未必知道的49个CSS知识点 10 个 GitHub 上超火的 CSS 奇技淫巧项目，找到写 CSS 的灵感！ 改善 CSS 的 10 个最佳实践 我写CSS的常用套路 妙用CSS变量，让你的CSS变得更心动 其他Webpack 详解 当面试官问Webpack的时候他想知道什么 🔥【万字】透过分析 webpack 面试题，构建 webpack5.x 知识体系 深入浅出 Vite Vite 3.0 正式发布，下一代前端构建工具！ 漫谈构建工具(四): 为什么有人说 vite 快，有人却说 vite 慢？ pnpm 是凭什么对 npm 和 yarn 降维打击的 关于现代包管理器的深度思考——为什么现在我更推荐 pnpm 而不是 npm/yarn? pnpm快到碗里来！ 🚀Turborepo：发布当月就激增 3.8k Star，这款超神的新兴 Monorepo 方案，你不打算尝试下吗？ Turborepo: 是时候给你的monorepo仓库上上对抗了 你会用ES6，那倒是用啊！ ES6、ES7、ES8、ES9、ES10新特性一览 JS正则表达式完整教程（略长） 记好这 24 个 ES6 方法，用来解决实际开发的 JS 问题 学习网站掘金 思否 CSDN github ….","link":"/wrh.github.io/2023/08/23/%E5%BC%A0%E6%8C%AF%E6%B0%91%E6%95%99%E8%82%B2%E7%A7%91%E6%8A%80%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"title":"Sentry异常分类","text":"Sentry应该关注的点更多的应该聚焦在崩溃率，Sentry上的异常是多种多样的有自定义的异常统计也有Sentry本身捕获到的异常，具体观察异常的时候通常需要开发人员的参与。目前Sentry中的bk项目为听力前端异常监控。 自定义异常bk项目中的自定义异常目前有两个 接口http异常 接口业务异常 接口http异常的逻辑是指本身的http请求异常，如接口超时，接口404，接口403，服务器宕机等非正常的http请求结果会上报Sentry，这时需要后端的同事参与进行修复，需要注意的是如果是用户的终端设备本身断网也会统计，此时需要根据具体情况具体分析。 接口业务异常的逻辑是指接口返回了不符合约定的code码，约定的数据接口格式为 123456{ code: 200, data: ..., msg: &quot;请求成功&quot;, success: true,} 如果有接口返回的code和约定的不一致则会上报Sentry，此时也需要后端的同事参与进行修复，需要注意的是有些接口返回不符合约定的code是正常情况，如登录超时，验证码错误等，此时需要根据具体情况具体分析。 Sentry捕获的异常Sentry中捕获异常的逻辑为全局捕获Error信息并上报，所以在上报的异常中并不代表所以异常都会导致程序崩溃白屏，往往需要根据上报次数和影响人数来区分优先级 异常可大致分为: 恶行bug会导致程序崩溃白屏，此类异常往往可以根据发生次数和影响人数来判断，还可以根据Sentry中有没有精确的代码捕获来判断是否是此类异常 过低版本浏览器引发的bug，此类异常往往是由于本身浏览器或微信版本过低，没有提供一些必要的方法，判断此类异常需要具体分析设备的版本以及报错信息 浏览器本身的报错信息，由于Sentry是全部捕获Error信息所以会导致浏览器本身抛出的异常信息也会统计上报，此类异常往往是发生次数极低影响用户极少，需要根据错误信息具体分析 资源加载的报错信息，目前的音频文件因为本身需要浏览器的播放器支持，所以如果资源本身出现问题导致的播放问题也会统计上报 解决方法: 恶行bug的特性是传播多，影响大，同时也相对容易定位，解决办法通常是修复掉具体的异常代码块即可 过低版本浏览器导致的问题，需要具体分析，有些问题可以通过手动打包添加相对应的polyfill来适配低版本浏览器，有些问题则客观上无法解决。 浏览器本身的问题，无法通过前端的代码来进行修复。 资源加载的问题可以通过和后端同事的配合来进行相应的解决，但无法从根本上解决此类问题。","link":"/wrh.github.io/2023/09/11/Sentry%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB/"},{"title":"前端通用组件化方案报告","text":"引言随着Web技术的不断发展，前端开发已经进入了组件化时代。组件化开发可以提高开发效率，降低维护成本，使得前端代码更具有可重用性和可扩展性。本报告旨在探讨一种通用的前端组件化方案，以便适应不同的项目需求和技术栈。 需求分析随着项目增多发现现在多个项目中有一些重复的场景可以被封装为组件复用,也有一些重复的逻辑可以被封装为通用库,包括不限于: 不同项目的接口请求逻辑可以被复用 不同项目的异常处理逻辑可以被复用 听力前后端和试卷网项目的视频播放组件 听力前后端移动版和PC版音频播放组件 不同项目的图片上传组件 试卷网后台和蚂蚁云盘的批量上传逻辑 通用的树结构数据处理逻辑 … 封装的通用组件目标: 可供React、微信小程序场景接入 满足逻辑封装和组合的需求，具备易用的编程模型，包括但不仅限于数据驱动视图、响应式数据、事件、生命周期、以及父子组件通信所需要的props和emit特性。 具备Context API、状态管理、TS支持 方案考略到需要兼容React以及微信小程序同时微信小程序是使用taro框架编写，封装的组件库应该使用React语言编写。 除了代码语言外还应该考略的问题有以下几点: 组件库本身如何快速迭代开发？ 前端项目如何方便简单的安装封装的组件库? 开发人员如何快速的上手组件库，如何压平前端的上手学习曲线？ 如何不重复制造轮子？ 结合公司实际情况以及目前市面上已有的方案有如下解决办法: 组件库本身如何快速迭代开发？ 组件库本身也是作为一个项目来搭建的配合gitlab和一些开源方案如dumi、VitePress、Rspack就和开发普通的前端项目一样，迭代起来也是非常方便。 前端项目如何方便简单的安装封装的组件库? 考略到要支持React以及微信小程序代码必然要抹平平台间的差异，所以代码本身一定是需要对不同平台做出不同处理，如果还是按照平时的开发习惯可能会导致大量的耦合代码出现，应该采用类似现在流行的Multi repo方式开发，采用这种方式开发的知名项目有react和Vue等等，采用这种方式开发可以使用Turbo repo这个框架来加速编译的过程。 开发人员如何快速的上手组件库，如何压平前端的上手学习曲线 应该构建好完善的开发文档可以采用上述介绍过构建工具大致效果如下: 上述效果是采用dumi完成 如何不重复制造轮子？ 封装通用组件库的核心逻辑是在与节省开发过程中的部分重复工作量，并不是在于封装这一过程，如果已经有现成的解决方案如ProTable、ProModal等珠玉在前的方案开发过程中不应再过多封装这些场景。 封装的组件本身应该做好封装,继承,多态,抽象,举一个例子 上传图片的组件我们开发过程中不能只考虑上传的过程，应该同时考略到上传成功后的回调,上传失败的回调，上传验证的问题，以及批量上传，或者上传了文件类型等非图片格式。 缺点一个事件有好处的同时必然也伴随着许多劣势，是否采用要在于取舍，封装通用组件库的劣势有如下几点 组件库升级不方便，如上传图片最开始只支持一次性上传9张图片，现在有新需求期望支持更多的图片，需要先更新组件库代码并且打包发布，然后开发在升级该库才能完成需求。 有沟通成本，A开发的组件库B在使用，B有新需求需要再和A沟通后由A打包发布B再验证代码。如果需求未完成还需继续沟通。 有维护成本，目前没有专门维护组件库的人员，如果都参与到组件库的开发同时碰到自身有项目开发的时候必然导致维护成本增加","link":"/wrh.github.io/2023/10/23/%E5%89%8D%E7%AB%AF%E7%BB%84%E4%BB%B6%E5%8C%96%E6%8A%A5%E5%91%8A/"}],"tags":[{"name":"前端","slug":"前端","link":"/wrh.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Flutter","slug":"Flutter","link":"/wrh.github.io/tags/Flutter/"},{"name":"ReactNative","slug":"ReactNative","link":"/wrh.github.io/tags/ReactNative/"}],"categories":[{"name":"公司文档","slug":"公司文档","link":"/wrh.github.io/categories/%E5%85%AC%E5%8F%B8%E6%96%87%E6%A1%A3/"},{"name":"代码规范","slug":"代码规范","link":"/wrh.github.io/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"调研报告","slug":"调研报告","link":"/wrh.github.io/categories/%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/"},{"name":"混合开发","slug":"混合开发","link":"/wrh.github.io/categories/%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/"}]}